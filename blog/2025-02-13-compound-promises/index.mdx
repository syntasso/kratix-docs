---
slug: compound-promises
title: "How to write Compound Promises in Kratix"
description: Everything you need to know about building Compound Promises in Kratix
authors: [derik]
tags: [kratix, promises, compound promise]
---


So you read the [guide](/main/guides/compound-promises) on Compound Promises and tried out the Workshop, but you are still wondering how you would _really_ go about writing a compound promise.

We hear you.

In this blog post, we will build a Compound Promise from scratch. Consider this the ultimate guide on how to build compound promises effectively.

You can follow this guide and build the Promise along with us, or you can use it as a reference when building your own Compound Promises. The Promise we will build is available [here](https://github.com/syntasso/kratix-docs/tree/main/assets/rubyapp-promise).

After reading this post you will:

* Learn about some basic Kratix concepts
* Learn how to write a Compound Promise:
  * By transforming an user's request into a series of sub-requests
  * By sending those sub-requests to the Platform cluster (and why you need it)
  * By defining the sub-Promises that the parent Promise depends on

Click on "read more" to continue!

{/* truncate */}

Before we start, let's clarify a few words we will use in abundance throughout this article:

* **Promise**: the basic building block in Kratix. A Promise is the definition of something-as-a-service. If you are not sure what a Promise is, I recommend reading some of our other documentation first, like [Installing and using a Promise](/main/guides/installing-a-promise)
* **Workflow**: defined within a Promise, it transforms the user's request into reality
* **Compound Promise**: a Promise that orchestrates one or more Promises. We may refer to it as "the parent promise" or "the super promise" in this article
  * The Promises that a Compound Promise is orchestrating may be referred to as "child promises" or "sub-promises"

Now that we understand each other, let's dive into, well, the reason you are here: building a compound promise. I'm going to split this article into the following sections:

* Defining the experience
* Creating the sub-promises
* Creating a Compound Promise

## The experience

With our internal platforms, we want to give developers a similar experience as they could have with a SaaS provider like Heroku or Fly.io. The biggest benefit of those platforms is how they make getting off the ground very easily, while still providing hooks for advanced users.

[Deploying a Rails application to fly.io](https://fly.io/docs/rails/getting-started/existing/), for example, is basically a single command. The `flyctl` CLI will interactively ask the user if they need a PostgreSQL database and a Redis cache with their application. Depending on their answers, it will go ahead and provision those services and bind them to the application via config files or environment variables. The application will eventually be deployed and available.

Kratix makes building a similar experience in your internal platform as easy. While it is possible to build all of that in a single Promise, a better approach is to build smaller, single-responsibility Promises–like a dedicated PostgreSQL Promise–and then create a Promise at a higher-level of abstraction that orchestrates requesting the lower-level resources. That higher-level Promise is what we call a **Compound Promise**.

```mdx-code-block
import Figure01 from "./figure01.png"
```

<figure className="diagram">
  <img className="large" src={Figure01} alt="The high-level RubyApp Promise
  orchestrating sub-level promises" />

  <figcaption>How a Compound Promise processes requests</figcaption>
</figure>


:::tip[When should I use Compound Promises?]

This is a question we hear often. Compound Promises are a great way to abstract away complex operations, turning complicated orchestration of many sub-promises into a single request.

Generally speaking, you should consider the questions below:

* Do you want enable requests to the sub-Promises directly?

  In our example, would people want to request a PostgreSQL database _without_ an associated application? If the answer is "yes", then you probably want to create a dedicated Database Promise, and create a Compound Promise that uses it.

* Who owns the sub-Promises?

  Compound Promises are especially useful when the Platform team is curating services provided by other internal teams (or external vendors)

* How much complexity do you want expose to your users?

  Sometimes a simple Cache Promise can get quite complicated depending on the number of configurations you want to expose. Abstracting the API into a Compound Promise allows you to enable both simple and complex use-cases.

:::

To deploy a Rails application into our internal platform, we want to draw on the fly.io experience: users should be able to deploy their app and optionally include a Database and/or a cache. Depending on the request, the appropriate resources should be created and, eventually, the application should be accessible via a URL.

In Kratix terms, we want the user's request to our RubyApp promise to look like this:

```yaml
apiVersion: internal.platform.io/v1
kind: RubyApp
metadata:
  name: my-app
  namespace: default
spec:
  image: myorg/ruby-app:v1.0.0
  database:
    driver: postgresql
  cache:
    driver: redis
```

## Building the Promise

:::tip[Skip the build!]

You can follow this guide and build the Promise along with us, or you can use it as a reference when building your own Compound Promises.

The Promise mentioned in this post is available [here](https://github.com/syntasso/kratix-docs/tree/main/assets/rubyapp-promise).

You can skip straight to [installing the Promise](#install) if you want to see it in action.

:::


With the API and experience defined, let's create this Promise. We can use the [Kratix CLI](/main/kratix-cli/intro) to speed up development. Create a new directory in your system and initialise a new Promise:

```bash
mkdir rubyapp-promise && cd rubyapp-promise

kratix init promise rubyapp \
  --group internal.platform.io \
  --kind RubyApp \
  --version v1
```

The command above should produce a `promise.yaml` in the `rubyapp-promise` directory. We can now define the API properties we defined above:

```bash
kratix update api \
  --property image:string \
  --property database.driver:string \
  --property cache.driver:string
```

Great. All we need now is the workflow that will transform the user's request into the requested resources. To quick-start the workflow, run the `kratix add container` command:

```bash
kratix add container resource/configure/instance \
  --image ghcr.io/syntasso/kratix-docs/rubyapp-promise:v1.0.0 \
  --name deploy-resources
```

At this point, your local `rubyapp-promise` directory should look like this:

```
.
├── README.md
├── example-resource.yaml
├── promise.yaml
└── workflows
    └── resource
        └── configure
            └── instance
                └── deploy-resources
                    ├── Dockerfile
                    ├── resources
                    └── scripts
                        └── pipeline.sh

8 directories, 5 files
```

But what should our pipeline script do? It should:

* Deploy the application specified with the specified image.
* Create a PostgreSQL instance if `database.driver` is set to `postgresql`.
  * Update the application environment variables with the PostgreSQL connection details.
* Create a Redis instance if `cache.driver` is set to `redis`.
  * Update the application environment variables with the Redis connection details.

To achieve that, the RubyApp Promise will actually orchestrate three lower-level promises:

* A PostgreSQL Promise responsible for provisioning a PostgreSQL database.
* A Redis Promise responsible for provisioning a Redis cache.
* A Runtime Promise responsible for deploying and running the application.

Those Promises are all available in the [Kratix Marketplace](/marketplace). All the pipeline needs to do then, is generate the requests to those sub-promises based on the user's input.

Open the `pipeline.sh` script in `workflows/resource/configure/instance/deploy-resources/scripts` and update it to:


```bash
#!/usr/bin/env sh

app_name="$(yq eval '.metadata.name' /kratix/input/object.yaml)"
namespace="$(yq '.metadata.namespace' /kratix/input/object.yaml)"

# The image to deploy
app_image="$(yq '.spec.image' /kratix/input/object.yaml)"

# The database driver; defaults to empty string
database_driver="$(yq '.spec.database.driver // ""' /kratix/input/object.yaml)"

# The cache driver; defaults to empty string
cache_driver="$(yq '.spec.cache.driver // ""' /kratix/input/object.yaml)"

# Output the runtime request: we always want to deploy the app
yq ".metadata.name = \"${app_name}\" | .spec.image = \"${app_image}\"" resources/runtime-request-template.yaml > /kratix/output/runtime-request.yaml

# Output the database request if the databaseDriver is set to postgresql
if [ "$database_driver" = "postgresql" ]; then
  yq ".metadata.name = \"${app_name}-db\" | .spec.teamId = \"${app_name}\"" resources/postgres-request-template.yaml > /kratix/output/postgres-request.yaml

  # name of the secret generated by the postgres promise
  secret_ref="${app_name}.${app_name}-${app_name}-db-postgresql.credentials.postgresql.acid.zalan.do"

  # Inject PostgreSQL environment variables directly into runtime-request.yaml
  cat <<EOF >> /kratix/output/runtime-request.yaml
    - name: PGHOST
      value: ${app_name}-${app_name}-db-postgresql.default.svc.cluster.local
    - name: DBNAME
      value: bestdb
    - name: PGUSER
      valueFrom:
        secretKeyRef:
          name: ${secret_ref}
          key: username
    - name: PGPASSWORD
      valueFrom:
        secretKeyRef:
          name: ${secret_ref}
          key: password
EOF
fi

# Output the redis request if the cacheDriver is set to redis
if [ "$cache_driver" = "redis" ]; then
  yq '.metadata.name = "'${app_name}'-cache"' resources/redis-request-template.yaml > /kratix/output/redis-request.yaml

  # Inject Redis environment variables directly into runtime-request.yaml
  cat <<EOF >> /kratix/output/runtime-request.yaml
    - name: REDIS_URL
      value: "redis://rfs-${app_name}-cache:26379/1"
    - name: REDIS_POOL_SIZE
      value: "5"
EOF
fi
```

You may notice that we are referencing a `resources` directory in the script. If you inspect the Dockerfile, you will see that the `resources` directory is added to the container, and it contains the contents of the local `resources` directory.

Let's populate the local directory with the templates the script will use. They represent a basic request to the Promises our Compound Promise will use. Let's download the example request each directly from the sub-Promises repository:

From the `rubyapp-promise` directory, run:

```bash
curl -o postgres-request-template.yaml https://raw.githubusercontent.com/syntasso/promise-postgresql/refs/heads/main/resource-request.yaml
curl -o redis-request-template.yaml https://raw.githubusercontent.com/syntasso/kratix-marketplace/refs/heads/main/redis/resource-request.yaml
curl -o runtime-request-template.yaml https://raw.githubusercontent.com/syntasso/kratix-marketplace/refs/heads/main/runtime/resource-request.yaml

mkdir -p workflows/resource/configure/instance/deploy-resources/resources/
mv *-request-template.yaml workflows/resource/configure/instance/deploy-resources/resources/
```

There are only two things left to do in our Compound Promise:

* Ensure the outputs of the pipeline are scheduled to the Platform cluster
* Set the sub-Promises as requirements for the Compound Promise

The next sections will explore how to do this.

### Scheduling to the Platform cluster

Let take a moment to revisit the behaviour of installing a normal Promise. When a Promise is applied on the Platform cluster, Kratix ensures the API defined within the Promise becomes available in the Platform as a CRD, which enable users to make request to those Promises. The Promise dependencies, on the other hand, are installed on any Destination that could run the workloads.

The Runtime Promise we will use, for example, has a dependency on the Nginx Controller. When that promise is applied, that dependency is installed into any Destination that can receive Runtime instances. When a user requests a new instance, they use the Runtime API to trigger the workflows, that will in turn generate the documents that will be scheduled to the Destination.

```mdx-code-block
import Figure02 from "./figure02.png"
```

<figure className="diagram">
  <img className="large" src={Figure02} alt="The Runtime Promise" />

  <figcaption>The Runtime Promise and it's point of interaction</figcaption>
</figure>

Compound Promises behave the exact same way: in response of a user's request, a workflow is executed and a set of documents are generated. Those documents are stored in the State Store to be picked up by a GitOps agent. The difference here is that those documents are themselves requests for other Promises. That means that the Cluster reconciling on the State Store must be able to understand the CRD of the sub-Promises. In most cases, that means scheduling the documents to the Platform cluster itself.


```mdx-code-block
import Figure03 from "./figure03.png"
```

<figure className="diagram">
  <img className="large" src={Figure03} alt="The Platform cluster reconciling on the State store" />

  <figcaption>Scheduling documents to the Platform cluster</figcaption>
</figure>

To ensure that the documents generated by the RubyApp Promise are scheduled to the Platform cluster, we need to:

1. Create a Destination representing the platform with some specific labels, like `environment=platform`
2. Configure the GitOps agent in the Platform cluster
3. Add Destination Selectors in the Compound Promise.

We won't go into details (1) and (2) in this blog post. You can find more information on how to [Registering the Platform as a Destination](/workshop/installing-kratix#register-the-platform-as-a-destination) in the Kratix workshop.

:::tip

To quickly get an environment compatible with the promises in this blog post, clone Kratix and run:

```bash
make quick-start
make prepare-platform-as-destination
```

:::

At this stage, you should see the following when listing the Destinations in your Platform cluster:

```shell-session
$ kubectl --context $PLATFORM get destinations --show-labels
NAME               READY   LABELS
platform-cluster   True    environment=platform
worker-1           True    environment=dev
```

For (3), open your Promise file and, under `spec`, add the following:

```yaml
apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  creationTimestamp: null
  name: rubyapp
spec:
  #highlight-start
  destinationSelectors:
  - matchLabels:
      environment: platform
  #highlight-end
  api: #...
```

:::tip

It is possible to dynamically generate the destination selectors by creating a `destination-selectors.yaml` file in the `/kratix/metadata/` directory in the Workflow. You can read more about it in [Managing Multiple Destinations](/main/reference/destinations/multidestination-management).

:::

The above declaration tellls Kratix to _schedule the outputs of this Promise to a Destination with the label `environment=platform`_. Since we configured the Platform destination with this label, we already have everything in place for the RubyApp Promise to work.


### Define the Promise requirements

The final piece missing in our Compound Promise is the declaration of the sub-Promises it depends on. For that, you set the `spec.requiredPromises` field in the Compount Promise document with a list of sub-Promise names and versions.

Let's update our RubyApp Promise to include the required sub-Promises:


```yaml
apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  creationTimestamp: null
  name: rubyapp
spec:
  #highlight-start
  requiredPromises:
  - name: postgresql
    version: v1.0.0-beta.2
  - name: redis
    version: v0.1.0
  - name: runtime
    version: v1.0.0
  #highlight-end
  destinationSelectors: #..
  api: #...
```

We are now ready to install it!

## Installing the Promise {#install}

If we try to install the Compound Promise now, you should get a warning:

```shell-session
$ kubectl --context $PLATFORM apply --filename rubyapp-promise.yaml
Warning: Required Promise "postgresql" at version "v1.0.0-beta.2" not installed
Warning: Required Promise "redis" at version "v1.0.0-beta.1" not installed
Warning: Required Promise "runtime" at version "v0.1.0" not installed
Warning: Promise will not be available until the above issue(s) is resolved
promise.platform.kratix.io/rubyapp configured
```

The Compound Promise itself will remain unavailable until the requirements are satisfied.

```shell-session
$ kubectl --context $PLATFORM get promises
NAME      STATUS        KIND      API VERSION               VERSION
rubyapp   Unavailable   RubyApp   internal.platform.io/v1
```

To satisfy the `requiredPromises` declaration, you will to, well, install the required promises in your Platform cluster:

```bash
kubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/promise-postgresql/main/promise-release.yaml
kubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/redis/promise-release.yaml
kubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/runtime/promise-release.yaml
```

After a few seconds, you should see all the Promises available in your Platform:

```shell-session
$ kubectl --context $PLATFORM get promises
NAME         STATUS      KIND         API VERSION                      VERSION
postgresql   Available   postgresql   marketplace.kratix.io/v1alpha1   v1.0.0-beta.2
redis        Available   redis        marketplace.kratix.io/v1alpha1   v0.1.0
rubyapp      Available   RubyApp      internal.platform.io/v1
runtime      Available   Runtime      marketplace.kratix.io/v1alpha1   v1.0.0
```

:::tip

You may have noticed that we are applying a different type of resource: a Promise Release. This blog post will not go into detail on the Promise Releases, but you can find more information on them [here](/main/reference/promises/releases).

:::

You are now ready to send requests to your Compound Promise!

## Deploying the application

Now that you have everything set in the Platform, you can go ahead and deploy the your applications!

For that, create a request for your RubyApp Promise:

```yaml
cat <<EOF | kubectl --context $PLATFORM apply -f -
apiVersion: internal.platform.io/v1
kind: RubyApp
metadata:
  name: example-rubyapp
spec:
  image: syntasso/example-rails-app:v1.0.0 # you can use this one, or build your own
  database:
    driver: postgresql
  cache:
    driver: redis
EOF
```

Sending this request will immediately trigger the RubyApp Promise Resource workflow. That, in turn, should trigger the sub-promises workflows:

```shell-session
$ kubectl --context $PLATFORM get pods
NAME                                                              READY   STATUS      RESTARTS   AGE
kratix-rubyapp-example-rubyapp-instance-245f2-4w5j8               0/1     Completed   0          10m
kratix-postgresql-example-rubyapp-db-instance-configure-cf8bwqg   0/1     Completed   0          10m
kratix-redis-example-rubyapp-cache-instance-configure-04845m74r   0/1     Completed   0          10m
kratix-runtime-example-rubyapp-instance-d7a3e-9lczv               0/1     Completed   0          10m
```

In a couple of minutes, in your Worker cluster, you should see the application pod running, alongside the Redis and PostgreSQL databases:

```shell-session
NAME                                              READY   STATUS    RESTARTS   AGE
example-rubyapp-64dcfbd9c8-khs98                  1/1     Running   0          10m
example-rubyapp-example-rubyapp-db-postgresql-0   1/1     Running   0          10m
rfr-example-rubyapp-cache-0                       1/1     Running   0          10m
rfs-example-rubyapp-cache-545547d5c6-d8m69        1/1     Running   0          10m
# some other pods
```

And you can now access your application:

```mdx-code-block
import RunningApp from "./running-app.png"
```

<figure className="diagram">
  <img className="large" src={RunningApp} alt="Rails application running with
  PostgreSQL and Redis " />

  <figcaption>The running Rails App</figcaption>
</figure>

🎉 The App is up-and-running! The RubyApp Promise has successfully orchestrated the provisioning of the PostgreSQL and Redis databases, and the deployment of the application. It then wired the application to the databases by injecting the connection details into the environment variables.

## Conclusion

In this blog post, we have built a Compound Promise from scratch. We have defined the experience we want to provide to our users, created the sub-promises that the Compound Promise depends on, and created the Compound Promise itself.

We have also seen how to schedule the outputs of the Compound Promise to the Platform cluster, and how to define the sub-Promises as requirements for the Compound Promise.

Hopefully you now have a better understanding of how to build Compound Promises! If you have any questions, feel free to reach out to us on [Slack](https://kratix.slack.com) or [GitHub](https://github.com/syntasso/kratix).
