---
slug: compound-promises
title: "How to write Compound Promises in Kratix"
description: Everything you need to know about building Compound Promises in Kratix
authors: [derik]
tags: [kratix, promises, compound promise]
---

```mdx-code-block
import Figure01 from "./figure01.png"
```

<figure className="diagram">
  <img className="large" src={Figure01} alt="High level diagram explaining how
Kratix processes requests" />

  <figcaption>How Kratix processes a request to a Kubernetes Destination</figcaption>
</figure>

So you read the [guide](/main/guides/compound-promises) on Compound Promises and tried out the Workshop, but you are still wondering how you would _really_ go about writing a compound promise.

We hear you. 

In this blog post, we will build a Compound Promise from scratch. Consider this the ultimate guide on how to build compound promises effectively.

You will need:

* A Kubernetes Cluster running Kratix
// Potentially a worker and a platform
* A text editor
* A couple of Promises
* A love for YAML

After reading this post you will:

* Learn about some basic Kratix concepts
* Learn about Promise Releases
* Learn how to make a Promise dependant on other Promises
* Learn how to transform a Compound Promise request into subrequests.

Click on "read more" to continue!

{/* truncate */}

Before we start, let's clarify a few words we will use in abundance throughout this article:

* **Promise**: the basic building block in Kratix. A Promise is the definition of something-as-a-service. If you are not sure what a Promise is, I recommend reading some of our other documentation first, like [Installing and using a Promise](/main/guides/installing-a-promise)
* **Workflow**: defined within a Promise, it transforms the user's request into reality
* **Compound Promise**: a Promise that orchestrates one or more Promises. We may refer to it as "the parent promise" or "the super promise" in this article
  * The Promises that a Compound Promise is orchestrating may be referred to as "child promises" or "sub-promises"

Now that we understand each other, let's dive into, well, the reason you are here: building a compound promise. I'm going to split this article into the following sections:

* Defining the experience
* Creating the sub-promises
* Creating a Compound Promise

## The experience

With our internal platforms, we want to give developers a similar experience as
they could have with a SaaS provider like Heroku or Fly.io. The biggest
benefit of those platforms is how they make getting off the ground very easily,
while still providing hooks for advanced users.

[Deploying a Rails application to fly.io](https://fly.io/docs/rails/getting-started/existing/), for example, is basically a single command. The `flyctl` CLI will interactively ask the user if they need a PostgreSQL database and a Redis cache with their application. Depending on their answers, it will go ahead and provision those services and bind them to the application via config files or environment variables. The application will eventually be deployed and available.

Kratix makes building a similar experience in your internal platform as easy. While it is possible to build all of that in a single Promise, a better approach is to build smaller, single-responsibility Promises–like a dedicated PostgreSQL Promise–and then create a Promise at a higher-level of abstraction that orchestrates requesting the lower-level resources. That higher-level Promise is what we call a **Compound Promise**.

//TODO: diagram


:::tip[When should I use Compound Promises?]

This is a question we hear often. Compound Promises are a great way to abstract away complex operations, turning complicated orchestration of many sub-promises into a single request.

Generally speaking, you should consider the questions below:

* Do you want enable requests to the sub-Promises directly?
   
  In our example, would people want to request a PostgreSQL database _without_ an associated application? If the answer is "yes", then you probably want to create a dedicated Database Promise, and create a Compound Promise that uses it.
   
* Who owns the sub-Promises? 

  Compound Promises are especially useful when the Platform team is curating services provided by other internal teams (or external vendors)

* How much complexity do you want expose to your users?

  Sometimes a simple Cache Promise can get quite complicated depending on the number of configurations you want to expose. Abstracting the API into a Compound Promise allows you to enable both simple and complex use-cases.

:::

To deploy a Rails application into our internal platform, we want to draw on the fly.io experience: users should be able to deploy their app and optionally include a Database and/or a cache. Depending on the request, the appropriate resources should be created and, eventually, the application should be accessible via a URL.

In Kratix terms, we want the user's request to our RubyApp promise to look like this:

```yaml
apiVersion: internal.platform.io/v1
kind: RubyApp
metadata:
  name: my-app
  namespace: default
spec:
  image: myorg/ruby-app:v1.0.0
  database:
    driver: postgresql
  cache:
    driver: redis
```

## Building the Promise

With the API and experience defined, let's create this Promise. We can use the [Kratix CLI](/main/kratix-cli/intro) to speed up development. Create a new directory in your system and initialise a new Promise:

```bash
mkdir rubyapp-promise && cd rubyapp-promise

kratix init promise rubyapp \
  --group internal.platform.io \
  --kind RubyApp \
  --version v1
```

The command above should produce a `promise.yaml` in the `rubyapp-promise` directory. We can now define the API properties we defined above:

```bash
kratix update api \
  --property image:string \
  --property database.driver:string \
  --property cache.driver:string
```

Great. All we need now is the workflow that will transform the user's request into the requested resources. To quick-start the workflow, run the `kratix add container` command:

```bash
kratix add container resource/configure/instance \
  --image syntasso/ruby-app:v1.0.0 \
  --name deploy-resources
```

At this point, your local `rubyapp-promise` directory should look like this:

```
.
├── README.md
├── example-resource.yaml
├── promise.yaml
└── workflows
    └── resource
        └── configure
            └── instance
                └── deploy-resources
                    ├── Dockerfile
                    ├── resources
                    └── scripts
                        └── pipeline.sh

8 directories, 5 files
```

But what should our pipeline script do? It should:

* Create a PostgreSQL instance if `database.driver` is set to `postgresql`.
* Create a Redis instance if `cache.driver` is set to `redis`.
* Deploy the application specified in the image.

We will divide the above into three sub-promises:

* A PostgreSQL Promise responsible for provisioning a PostgreSQL database.
* A Redis Promise responsible for provisioning a Redis cache.
* A Runtime Promise responsible for deploying and running the application.

Today is your lucky day! All of those Promises are available in the [Kratix Marketplace](/marketplace). All our pipeline needs to do then, is generate requests to those sub-promises based on the user's request.

Open the `pipeline.sh` script in `workflows/resource/configure/instance/deploy-resources/scripts` and update it to look like this:

```bash
#!/usr/bin/env sh

app_name="$(yq eval '.metadata.name' /kratix/input/object.yaml)"
namespace="$(yq '.metadata.namespace' /kratix/input/object.yaml)"

# The image to deploy
app_image="$(yq '.spec.image' /kratix/input/object.yaml)"

# The database driver; defaults to empty string
database_driver="$(yq '.spec.database.driver // ""' /kratix/input/object.yaml)"

# The cache driver; defaults to empty string
cache_driver="$(yq '.spec.cache.driver // ""' /kratix/input/object.yaml)"

# Output the runtime request: we always want to deploy the app
yq '.metadata.name = "'${app_name}'"' resources/runtime-request-template.yaml > /kratix/output/runtime-request.yaml

# Output the database request if the databaseDriver is set to postgresql
if [ "$database_driver" = "postgresql" ]; then
  yq '.metadata.name = "'${app_name}'-db"' resources/postgres-request-template.yaml > /kratix/output/postgres-request.yaml

  # update the app env 
  # TODO
fi

# Output the redis request if the cacheDriver is set to redis
if [ "$cache_driver" = "redis" ]; then
  yq '.metadata.name = "'${app_name}'-cache"' resources/redis-request-template.yaml > /kratix/output/redis-request.yaml

  # update the app env 
  # TODO
fi

cat << EOF > /kratix/metadata/destination-selectors.yaml
- matchLabels:
    cluster: platform
EOF

```

You may notice that we are referencing a `resources` directory in the script. If you inspect the Dockerfile, you will see that the `resources` directory is added to the container, and it contains the contents of the local `resources` directory.

Let's populate the local directory with the templates the script will use. They represent a basic request to the Promises our Compound Promise will use. Let's download the example request each directly from the sub-Promises repository:

From the `rubyapp-promise` directory, run:

```bash
curl -o postgres-request-template.yaml https://raw.githubusercontent.com/syntasso/promise-postgresql/refs/heads/main/resource-request.yaml
curl -o redis-request-template.yaml https://raw.githubusercontent.com/syntasso/kratix-marketplace/refs/heads/main/redis/resource-request.yaml
TODO: add runtime example

mv *-request-template.yaml workflows/resources/configure/instance/deploy-resources/resources/
```

There are only two things left to do in our Compound Promise:

* Ensure the outputs of the pipeline are scheduled to the Platform cluster
* Set the sub-Promises as requirements for the Compound Promise

The next sections will explore how to do this.

### Scheduling to the Platform cluster

Let take a moment to revisit the behaviour of installing a Promise that is _not_ a Compound Promise. The Promise is installed on the Platform cluster, which, among other things, ensures the CRDs are installed on the Platform and accessible to any resource requests. Conversely, any dependencies of the Promise are installed on the Worker Clusters to ensure that they have the necessary capabilities . This could include Kubernetes operators that are then users to provision what the Promise provides as-a-service.

TODO Useful diagram here?

Where do Compound Promises fit in this scenario? To provision the resource of the sub-promises, the Compound Promise, within it's workflows, makes requests to the sub-promises. Because of this, like any other promise, to fulfill the requests of the sub-promises, the CRDs need to be installed on the Platform cluster. To ensure that these requests get scheduled to Platform Cluster, we can take advantage of a Kratix feature - Destination Selectors. Through the use of Destination Selectors, we can specify which Destinations - in this case, which Kubernetes cluster - to schedule the request to.

Destination Selectors, through key/value pairs, define matching locations to schedule workloads to.

Let's take a look at the `pipeline.sh` again. Within the script, we've defined a `destination-selectors.yaml` file with labels corresponding to the Destination the generated files should be scheduled to. 

```bash
cat << EOF > /kratix/metadata/destination-selectors.yaml
- matchLabels:
    cluster: platform
EOF
```

In this declaration of the Destination Selectors we are stating that file files generated within the workflow should be scheduled to the Destination that matches the label `cluster=platform`. However, we also need to ensure that that:

1. workloads can be scheduled to the Platform Cluster
2. the Platform Destination has the the required labels

#### Establishing the Platform as a Destination

For the Platform Cluster to be able to run workloads, it needs to be defined as location that Kratix knows it can schedule workloads to.

// TODO detail setup of the platform as a destination with the above label

### Define the Promise requirements

#### Promise Releases
