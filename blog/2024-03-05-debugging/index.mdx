---
slug: debugging-promise-updates
title: ""
description: Identifying the tools you can use to debug your Promise rollouts
authors: [sapphire]
tags: [kratix, kratix internals, debugging]
---

As much as we would all like, rolling out updates to any software can result in some bumps along the way. This applies to updates to Promises too but Kratix has some feature to help identify any issues within your Promise spec, your Promise workflows and the scheduling of documents outputted by your workflows.

In this blog post we'll explore some of the common issues that users experience when configuring Kratix and developing Promise and well as how Kratix tries to steer you in the right direction when something goes wrong. We'll be exploring:

- Feedback on Promise specifications
- Querying Kratix effectively with labels
- Getting information from status updates
- Kratix events

Click on "read more" to continue!

{/* truncate */}

## The end goal

The Kratix Marketplace contains an App as a Service Promise which deploys a Deployment configured with Nginx and a database if a user opts into using one. The one thing someone making a request of this Promise needs to provide is the image for their Deployment. By making updates to the Promise and Kratix resources, we'll highlight some common problems and the breadcrumbs to can follow to solve them.

You can follow the steps in this post and debug in your own environment. If you want to do this, start with the App-as-a-Service Promise [here](https://github.com/syntasso/kratix-docs/tree/main/assets/app-as-a-service-promise). (maybe use the one from the previous blog as it matched the cli directory structure?)

To optimise this Promise, we want to add a new Pipeline step that performs a security scan of the provided image and outputs the result as a HealthRecord in Kratix. We can bootstrap this step with the [Kratix CLI's](/main/kratix-cli/intro) `add container` command. From the root of the Promise directory, you can run:

```bash
kratix add container resource/configure/instance \
  --image ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0 \
  --name security-scan
```

This command adds a new container to the existing Resource configure workflow with the name `security-scan` and the image `ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0`. 

Your directory structure should now look like this:

```bash
├── example-resource.yaml
├── promise.yaml
└── workflows
    └── resource
        └── configure
            └── instance
                ├── deploy-resources
                │   ├── Dockerfile
                │   ├── resources
                │   │   ├── postgres-request-template.yaml
                │   │   ├── redis-request-template.yaml
                │   │   └── runtime-request-template.yaml
                │   └── scripts
                │       └── pipeline.rb
                └── security-scan
                    ├── Dockerfile
                    ├── resources
                    └── scripts
                        └── pipeline.sh
```

Next, we need to bring this image into existence. Update the new `pipeline.sh` file the the `security-scan` directory to look like this:

```
#!/usr/bin/env bash

set -ex

image="$(yq eval '.spec.image' /kratix/input/object.yaml)"

echo "Scanning ${image}"

trivy image ${image} --exit-code 1

echo "No vulnerabilities found"
```

In order to do this, we need to define a new container image to do this.

Whilst testing this command, we'll run in debug mode

// All images need to be scanned so a new pipeline is added
/// invalid Job
/// health record with wrong 


// new destination set up
// ca


              - image: ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0
                name: generate-healthrecord
                cmd: [ "generate-hr" ]

## Identifying invalid workflows



## Identifying invalid workflow definitions



