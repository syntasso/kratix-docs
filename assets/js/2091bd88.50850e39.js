"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[4693],{28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>a});var t=n(96540);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}},59906:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"main/platform-concepts/api","title":"API","description":"How Kratix uses Kubernetes CRDs to define Promise APIs.","source":"@site/docs/main/05-platform-concepts/08-api.mdx","sourceDirName":"main/05-platform-concepts","slug":"/main/platform-concepts/api","permalink":"/main/platform-concepts/api","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-platform-concepts/08-api.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"API","description":"How Kratix uses Kubernetes CRDs to define Promise APIs."},"sidebar":"mainSidebar","previous":{"title":"Authentication","permalink":"/main/platform-concepts/auth/authentication-oidc"},"next":{"title":"Introduction","permalink":"/main/kratix-cli/intro"}}');var i=n(74848),o=n(28453);const r={title:"API",description:"How Kratix uses Kubernetes CRDs to define Promise APIs."},a=void 0,c={},d=[{value:"CRDs and the Promise API",id:"crds-and-the-promise-api",level:2},{value:"CRD versions and Promise versions",id:"crd-versions-and-promise-versions",level:2}];function h(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["Kratix builds on Kubernetes Custom Resource Definitions (CRDs) to define the\nAPIs that platform users interact with. A CRD extends the Kubernetes API with a\nnew group, version, and kind (GVK), plus a schema that validates user requests.\nCRDs are highly customizable: you can set defaults, define enums, and enforce\nvalidation rules to shape how users request resources. For the full range of\ncapabilities, see the Kubernetes ",(0,i.jsx)(s.a,{href:"https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/",children:"Custom Resource Definitions"})," docs."]}),"\n",(0,i.jsx)(s.h2,{id:"crds-and-the-promise-api",children:"CRDs and the Promise API"}),"\n",(0,i.jsxs)(s.p,{children:["In a Promise, the ",(0,i.jsx)(s.code,{children:".spec.api"})," block is a CRD manifest. When you install the\nPromise, Kratix applies that CRD to the cluster. The CRD defines the request\nkind users create (for example ",(0,i.jsx)(s.code,{children:"Database"})," or ",(0,i.jsx)(s.code,{children:"App"}),") and the fields they can set\nwhen requesting a resource."]}),"\n",(0,i.jsx)(s.p,{children:"When you update the Promise API section, you are changing the CRD that Kratix\nmanages. That changes the request surface available to users and the schema\nvalidation Kubernetes enforces."}),"\n",(0,i.jsx)(s.h2,{id:"crd-versions-and-promise-versions",children:"CRD versions and Promise versions"}),"\n",(0,i.jsxs)(s.p,{children:["CRDs can define multiple API versions under a single kind, allowing you to\nevolve the schema over time while supporting older versions. The versioning\ninside a CRD does not have to match your Promise version. Some teams keep them\naligned, others change CRD versions only when the API shape changes, and use the\nPromise version for broader platform changes. For how Kratix versions Promises,\nsee ",(0,i.jsx)(s.a,{href:"/main/reference/promises/releases",children:"Promise Releases"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"For example:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["You add a new required field, change validation rules, or remove a field in\nthe Promise API. You might bump the CRD from ",(0,i.jsx)(s.code,{children:"v1alpha1"})," to ",(0,i.jsx)(s.code,{children:"v1alpha2"})," and also\nbump the Promise version (often a major or minor semver change) to make the API\nchange obvious to users."]}),"\n",(0,i.jsx)(s.li,{children:"You add an optional field or default that is backwards compatible. You might\nkeep the CRD version the same and bump only the Promise version (often a minor\nor patch semver change) to communicate the new capability."}),"\n",(0,i.jsx)(s.li,{children:"You update workflow logic, dependencies, or scheduling rules without changing\nthe API schema. You might bump the Promise version but keep the CRD version\nunchanged because the request shape is the same."}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["To see how the Promise API is defined, see the ",(0,i.jsx)(s.a,{href:"/main/reference/promises/intro",children:"Promise introduction"}),"."]})]})}function l(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);