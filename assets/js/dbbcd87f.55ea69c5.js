"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[2722],{71:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var s=t(5893),r=t(1151);const i=t.p+"assets/images/topology-00-146e2a739cfc5e9765ca3a958a5cfd4a.png",o={id:"create-clusters",title:"Creating the clusters",description:"In this section, you will create the Kubernetes clusters that will be used in the workshop. You will also configure the Worker to ensure it can run Kratix workloads."},a=void 0,l={id:"workshop/part-0/create-clusters",title:"Creating the clusters",description:"In this section, you will create the Kubernetes clusters that will be used in the workshop. You will also configure the Worker to ensure it can run Kratix workloads.",source:"@site/docs/workshop/part-0/02-create-clusters.mdx",sourceDirName:"workshop/part-0",slug:"/workshop/part-0/create-clusters",permalink:"/workshop/part-0/create-clusters",draft:!1,unlisted:!1,editUrl:"https://github.com/syntasso/kratix-docs/tree/main/docs/workshop/part-0/02-create-clusters.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"create-clusters",title:"Creating the clusters",description:"In this section, you will create the Kubernetes clusters that will be used in the workshop. You will also configure the Worker to ensure it can run Kratix workloads."},sidebar:"workshopSidebar",previous:{title:"Installing the tools",permalink:"/workshop/part-0/setup"},next:{title:"Part I",permalink:"/workshop/part-i/intro"}},c={},h=[{value:"Install the Platform Prerequisites",id:"install-the-platform-prerequisites",level:2},{value:"Cert-manager",id:"cert-manager",level:3},{value:"MinIO as the GitOps Repository",id:"minio-as-the-gitops-repository",level:3},{value:"Install the Worker prerequisites",id:"install-the-worker-prerequisites",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"One of the most powerful Kratix features is the ability platform teams have to fully control the scheduling of work across extensive and diverse infrastructure, i.e. to determine in which Kubernetes cluster (or other infrastructure) a certain workload should be deployed to. Kratix leverages the GitOps toolkit to deliver this capability."}),"\n",(0,s.jsxs)(n.p,{children:["Kratix itself runs in Kubernetes. The first step in getting Kratix up and running is to create a Kubernetes cluster where you can install it. In this workshop, you will use ",(0,s.jsx)(n.code,{children:"kind"})," to run Kubernetes clusters locally."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"You can run the workshop without KinD. Ideally, you will have access to two\nKubernetes clusters."}),(0,s.jsxs)(n.p,{children:["One cluster will be the Platform cluster, where Kratix will be installed.\nWhenever you see ",(0,s.jsx)(n.code,{children:"--context $PLATFORM"}),", replace it with the context of your\nplatform cluster."]}),(0,s.jsxs)(n.p,{children:["The other worker will be the Worker cluster. Whenever you see ",(0,s.jsx)(n.code,{children:"--context $WORKER"}),", replace it with the context of your worker cluster."]}),(0,s.jsxs)(n.p,{children:["If you want to try it on a single cluster, you can omit the ",(0,s.jsx)(n.code,{children:"--context"})," flag and\nargument entirely."]})]}),"\n",(0,s.jsx)(n.p,{children:"Within the Kratix repository, you will find two KinD configuration files that will make it easier to interact with the clusters. Start by cloning the repository locally:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"git clone https://github.com/syntasso/kratix\ncd kratix\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can now create the ",(0,s.jsx)(n.strong,{children:"Platform"})," cluster with the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# make sure there are no clusters running\nkind delete clusters --all\n\nkind create cluster \\\n    --name platform \\\n    --image kindest/node:v1.27.3 \\\n    --config config/samples/kind-platform-config.yaml\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Platform"})," cluster is the Kubernetes cluster where Kratix will be installed. It will also be the cluster where the Platform team will manage the Kratix configuration."]}),"\n",(0,s.jsxs)(n.p,{children:["Although it is possible to schedule workloads to the Platform cluster, it is not generally where most of the workloads will be deployed to.\nMore often, platform teams will have a dedicated set of clusters (and other varied infrastructure) where the requested services will actually run. In this workshop, you will use a second cluster to simulate this scenario. Whenever you read ",(0,s.jsx)(n.strong,{children:"Worker"})," cluster in the workshop, it will refer to this second cluster."]}),"\n",(0,s.jsxs)(n.p,{children:["Create the ",(0,s.jsx)(n.strong,{children:"Worker"})," cluster with the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kind create cluster \\\n    --name worker \\\n    --image kindest/node:v1.27.3 \\\n    --config config/samples/kind-worker-config.yaml\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To make it easier to interact with both clusters, set the ",(0,s.jsx)(n.code,{children:"PLATFORM"})," and ",(0,s.jsx)(n.code,{children:"WORKER"})," environment variables with each cluster context:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'export PLATFORM="kind-platform"\nexport WORKER="kind-worker"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can validate your clusters are running with the ",(0,s.jsx)(n.code,{children:"cluster-info"})," command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM cluster-info\nkubectl --context $WORKER cluster-info\n"})}),"\n",(0,s.jsx)(n.p,{children:"which should give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"Kubernetes control plane is running at https://127.0.0.1:65003\nCoreDNS is running at https://127.0.0.1:65003/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\n\nKubernetes control plane is running at https://127.0.0.1:65004\nCoreDNS is running at https://127.0.0.1:65004/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy\n"})}),"\n",(0,s.jsx)(n.h2,{id:"install-the-platform-prerequisites",children:"Install the Platform Prerequisites"}),"\n",(0,s.jsx)(n.h3,{id:"cert-manager",children:"Cert-manager"}),"\n",(0,s.jsxs)(n.p,{children:["Kratix requires ",(0,s.jsx)(n.a,{href:"https://cert-manager.io/",children:"cert-manager"})," to be installed in the cluster. Cert-manager is a Kubernetes add-on that automates the management and issuance of TLS certificates from various issuing sources."]}),"\n",(0,s.jsx)(n.p,{children:"To install it, run the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM apply --filename https://github.com/cert-manager/cert-manager/releases/download/v1.12.0/cert-manager.yaml\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can validate cert-manager is running with the following command:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get pods --namespace cert-manager\n"})}),"\n",(0,s.jsx)(n.p,{children:"which should give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME                                      READY   STATUS    RESTARTS   AGE\ncert-manager-7476c8fcf4-r8cnd             1/1     Running   0          19s\ncert-manager-cainjector-bdd866bd4-7d8zp   1/1     Running   0          19s\ncert-manager-webhook-5655dcfb4b-54r49     1/1     Running   0          19s\n"})}),"\n",(0,s.jsx)(n.h3,{id:"minio-as-the-gitops-repository",children:"MinIO as the GitOps Repository"}),"\n",(0,s.jsx)(n.p,{children:"As mentioned before, Kratix leverages GitOps for deploying and reconciling\nscheduled workloads. That means that Kratix needs a backing service to serve as the state store. Kratix supports two types of state stores: S3-compatible buckets and Git repositories. In this workshop, you will use a MinIO instance running in the platform cluster as the state store. In productions environment, you will probably use a Git repository or a S3-compatible bucket in a cloud provider."}),"\n",(0,s.jsx)(n.p,{children:"To install MinIO in the platform, run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# from the root of the Kratix repository\nkubectl --context $PLATFORM apply --filename config/samples/minio-install.yaml\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above command will:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Deploy an instance of MinIO on the ",(0,s.jsx)(n.code,{children:"kratix-platform-system"})," namespace"]}),"\n",(0,s.jsx)(n.li,{children:"Create a Secret with the MinIO credentials"}),"\n",(0,s.jsxs)(n.li,{children:["Run a Job to create a bucket called ",(0,s.jsx)(n.code,{children:"kratix"})," on the MinIO instance. ",(0,s.jsx)("br",{})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"You can verify the installation by running:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get deployments --namespace kratix-platform-system\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME     READY   UP-TO-DATE   AVAILABLE   AGE\nminio    1/1     1            1           1h\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can also verify the Create Bucket job:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get jobs\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME                  COMPLETIONS   DURATION   AGE\nminio-create-bucket   1/1           3m5s       1h\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once the Job completes, you should be able to see the ",(0,s.jsx)(n.code,{children:"kratix"})," bucket in the MinIO instance using the ",(0,s.jsx)(n.code,{children:"mc"})," CLI:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# configure the mc CLI to use the MinIO instance\nmc alias set kind http://localhost:31337 minioadmin minioadmin\n\n# list the buckets\nmc ls kind/\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"[2021-10-13 15:10:00 CEST]     0B kratix/\n"})}),"\n",(0,s.jsx)(n.p,{children:"You platform cluster is now ready to receive Kratix!"}),"\n",(0,s.jsx)(n.h2,{id:"install-the-worker-prerequisites",children:"Install the Worker prerequisites"}),"\n",(0,s.jsxs)(n.p,{children:["Kratix schedules workloads to destination clusters by writing a state declaration (following the Kubernetes\ndeclare-and-converge pattern) to a designated State Store. When it comes to\nreconciling the declared state on the destination cluster, Kratix remains agnostic about the specific tool\nto be used on the clusters. In this tutorial, you will utilise\n",(0,s.jsx)(n.a,{href:"https://fluxcd.io/",children:"Flux"})," on the destination cluster, and configure it to reconcile the\nstate from the MinIO bucket."]}),"\n",(0,s.jsx)(n.p,{children:"To install and configure Flux, run the following script from the Kratix\nrepository:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"./scripts/install-gitops --context $WORKER --path worker-cluster\n"})}),"\n",(0,s.jsx)(n.p,{children:"The script above will:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Install Flux"}),"\n",(0,s.jsxs)(n.li,{children:["Create a new Flux ",(0,s.jsx)(n.code,{children:"Bucket"})," Source"]}),"\n",(0,s.jsxs)(n.li,{children:["Create two Flux ",(0,s.jsx)(n.code,{children:"Kustomizations"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The Flux ",(0,s.jsx)(n.code,{children:"Kustomizations"})," are responsible for continuously reconciling with the state\ndeclared in the ",(0,s.jsx)(n.code,{children:"Source"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"If you are curious to know what this script does, or would prefer to configure the worker cluster yourself, take a look at the section below."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Configuring the cluster: the manual way"}),(0,s.jsx)(n.p,{children:"If you prefer to configure the worker cluster manually, follow the steps below."}),(0,s.jsx)(n.p,{children:"Install Flux on the worker cluster:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $WORKER apply --filename https://github.com/fluxcd/flux2/releases/download/v2.0.0-rc.3/install.yaml\n"})}),(0,s.jsxs)(n.p,{children:["Next, Flux must be configured to read from the MinIO bucket. For that, you will create a new\nFlux ",(0,s.jsx)(n.a,{href:"https://fluxcd.io/flux/components/source/buckets/",children:"Bucket Source"}),",\ntogether with a Secret containing the bucket credentials."]}),(0,s.jsxs)(n.admonition,{type:"caution",children:[(0,s.jsxs)(n.p,{children:["You may notice that the value of the Bucket ",(0,s.jsx)(n.code,{children:"endpoint"})," on the document below is\nset to ",(0,s.jsx)(n.code,{children:"172.18.0.2:31337"}),"."]}),(0,s.jsxs)(n.p,{children:["Flux now needs to access MinIO ",(0,s.jsx)(n.em,{children:"across"})," clusters, so you will need to use\nan externally available endpoint."]}),(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"172.18.0.2"})," will often be the address of the platform cluster running on KinD.\nYou can confirm this address with the following command:"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker inspect platform-control-plane | grep '\"IPAddress\": \"172' | awk -F '\"' '{print $4}'\n"})}),(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"172.18.0.2\n"})}),(0,s.jsx)(n.p,{children:"If the command above outputs a different IP, make sure to update the Bucket\nconfiguration below accordingly."}),(0,s.jsx)(n.p,{children:"The port part of the endpoint should always be 31337. Verify the NodePort of the\nMinIO service in the platform cluster:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get services minio --namespace kratix-platform-system\n"})}),(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME    TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE\nminio   NodePort   10.96.45.28   <none>        80:31337/TCP   1h\n"})})]}),(0,s.jsx)(n.p,{children:"Create the Flux Source Bucket (and Secret):"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"cat <<EOF | kubectl --context $WORKER apply -f -\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: minio-credentials\n  namespace: flux-system\ntype: Opaque\nstringData:\n  accesskey: minioadmin\n  secretkey: minioadmin\n---\napiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: Bucket\nmetadata:\n  name: kratix-bucket\n  namespace: flux-system\nspec:\n  interval: 10s\n  provider: generic\n  bucketName: kratix\n  endpoint: 172.18.0.2:31337 # make sure to read the caution box above\n  insecure: true\n  secretRef:\n    name: minio-credentials\nEOF\n"})}),(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"secret/minio-credentials created\nbucket.source.toolkit.fluxcd.io/kratix-bucket created\n"})}),(0,s.jsxs)(n.p,{children:["This tutorial will not dive into details of how to configure Flux Sources, but please read on their\n",(0,s.jsx)(n.a,{href:"https://fluxcd.io/flux/components/source/",children:"documentation"})," if you are curious."]}),(0,s.jsx)(n.p,{children:"Once the Bucket Source is created, validate that Flux can reach the bucket:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $WORKER get buckets.source.toolkit.fluxcd.io --namespace flux-system\n"})}),(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME            ENDPOINT           AGE     READY   STATUS\nkratix-bucket   172.18.0.2:31337   1h      True    stored artifact: revision 'sha256:some-sha'\n"})}),(0,s.jsxs)(n.p,{children:["Next, you must tell Flux what to do with this Source. Flux does continuous\ndelivery through the ",(0,s.jsx)(n.a,{href:"https://fluxcd.io/flux/components/kustomize/",children:"Kustomize\nController"}),". You can define a Flux\n",(0,s.jsx)(n.code,{children:"Kustomization"})," that watches for a Source and reconciles on events."]}),(0,s.jsx)(n.p,{children:"Create the Flux Kustomizations:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"cat <<EOF | kubectl --context $WORKER apply --filename -\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: kratix-workload-dependencies\n  namespace: flux-system\nspec:\n  interval: 8s\n  prune: true\n  sourceRef:\n    kind: Bucket\n    name: kratix-bucket\n  path: ./worker-cluster/dependencies\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: kratix-workload-resources\n  namespace: flux-system\nspec:\n  interval: 3s\n  prune: true\n  dependsOn:\n  - name: kratix-workload-dependencies\n  sourceRef:\n    kind: Bucket\n    name: kratix-bucket\n  path: ./worker-cluster/resources\nEOF\n"})}),(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"kustomization.kustomize.toolkit.fluxcd.io/kratix-workload-dependencies created\nkustomization.kustomize.toolkit.fluxcd.io/kratix-workload-resources created\n"})}),(0,s.jsx)(n.p,{children:"You will notice that there are two Kustomizations created. When scheduling\nworkloads, Kratix will separate the documents based on their GVK (Group, Version,\nKind):"}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["All dependencies (i.e. the Custom Resource Definition as defined\n",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#customresourcedefinition-v1-apiextensions-k8s-io",children:"here"}),")\nwill be written to a specific ",(0,s.jsx)(n.code,{children:"dependencies"})," path within the State Store."]}),"\n",(0,s.jsxs)(n.li,{children:["All other documents will be written to a specific ",(0,s.jsx)(n.code,{children:"resources"})," path within the\nState Store."]}),"\n"]}),(0,s.jsxs)(n.p,{children:["Later when you register the cluster as a Destination, Kratix will use the cluster's ",(0,s.jsx)(n.code,{children:"namespace"}),"\nand ",(0,s.jsx)(n.code,{children:"name"})," to build the full path for that cluster within the State Store."]}),(0,s.jsxs)(n.p,{children:["The first Kustomization above is for dependencies (CRDs), while the second is for the other\nresources (note the ",(0,s.jsx)(n.code,{children:"spec.path"}),"). You can also note that the\n",(0,s.jsx)(n.code,{children:"kratix-workload-resources"})," depends on the ",(0,s.jsx)(n.code,{children:"kratix-workload-dependencies"}),". That's to\navoid failures when a resource documents uses a GVK being defined by a CRD\ndocument."]}),(0,s.jsxs)(n.p,{children:["For further details on the naming convention for the buckets and paths, check\nthe ",(0,s.jsx)(n.a,{href:"../../main/reference/statestore/intro",children:"documentation"}),". For more on\nKustomizations, check ",(0,s.jsx)(n.a,{href:"https://fluxcd.io/flux/components/kustomize/kustomization/",children:"the Flux docs\npage"})]})]}),"\n",(0,s.jsx)(n.p,{children:"Wait for Flux to start:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $WORKER get deployments --namespace flux-system --watch\n"})}),"\n",(0,s.jsx)(n.p,{children:"The above command will give an output similar to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME                      READY   UP-TO-DATE   AVAILABLE   AGE\nhelm-controller           1/1     1            1           10m\nkustomize-controller      1/1     1            1           10m\nnotification-controller   1/1     1            1           10m\nsource-controller         1/1     1            1           10m\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Once the Ready column reports ",(0,s.jsx)(n.code,{children:"1/1"}),", press ",(0,s.jsx)("kbd",{children:"Ctrl"}),"+",(0,s.jsx)("kbd",{children:"C"})," to\nexit the watch mode."]}),"\n",(0,s.jsx)(n.p,{children:"At this stage, your environment looks like this:"}),"\n","\n","\n",(0,s.jsxs)("figure",{class:"diagram",children:[(0,s.jsx)("img",{class:"medium",src:i,alt:"Deployed resources after installing the prerequisites"}),(0,s.jsx)("figcaption",{children:"Current installation"})]}),"\n",(0,s.jsxs)(n.p,{children:["You are now ready to move to ",(0,s.jsx)(n.a,{href:"../part-i/intro",children:"Part I and install Kratix"}),"!"]})]})}function u(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var s=t(7294);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);