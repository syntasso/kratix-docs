"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[7726],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var s=n(96540);const a={},o=s.createContext(a);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:t},e.children)}},89576:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"main/platform-concepts/multi-tenancy","title":"Multi-tenancy","description":"Multi-tenancy for Kratix using standard Kubernetes isolation models.","source":"@site/docs/main/05-platform-concepts/06-multi-tenancy.mdx","sourceDirName":"main/05-platform-concepts","slug":"/main/platform-concepts/multi-tenancy","permalink":"/main/platform-concepts/multi-tenancy","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-platform-concepts/06-multi-tenancy.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"Multi-tenancy","description":"Multi-tenancy for Kratix using standard Kubernetes isolation models."},"sidebar":"mainSidebar","previous":{"title":"Secret management","permalink":"/main/platform-concepts/secrets"},"next":{"title":"Private Image Registries","permalink":"/main/platform-concepts/private-image-registries"}}');var a=n(74848),o=n(28453);const r={title:"Multi-tenancy",description:"Multi-tenancy for Kratix using standard Kubernetes isolation models."},i=void 0,c={},l=[];function d(e){const t={a:"a",code:"code",p:"p",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Kratix does not introduce a custom multi-tenancy layer. Instead, it fits into\nthe same Kubernetes isolation patterns you already use. Depending on your\nsecurity and operational requirements, you can isolate tenants with separate\nclusters, node pools, or namespaces."}),"\n",(0,a.jsxs)(t.p,{children:["Separate clusters are often used to reduce blast radius or to meet DR/HA or\nregulatory requirements. Node pools help ensure workloads and workflows run on\nthe right type of compute (for example, dedicated, compliant, or GPU nodes).\nNamespaces provide a lightweight boundary for teams. For example, an\norganisation might allocate ",(0,a.jsx)(t.code,{children:"backend"})," and ",(0,a.jsx)(t.code,{children:"frontend"})," namespaces so each team can\nmanage their own Promise requests independently from the same Platform."]}),"\n",(0,a.jsxs)(t.p,{children:["Kratix Promises can create namespaced CRDs and therefore resource requests\n(for example a Kratix Promise for ",(0,a.jsx)(t.code,{children:"Database"})," or ",(0,a.jsx)(t.code,{children:"App"}),") will be namespaced.\nThis makes namespaces a natural boundary for teams, environments, or\norganisations. You can then combine namespaces with Kubernetes features\nlike ResourceQuotas and NetworkPolicies to enforce limits and isolation per\nteam or other organisational division."]}),"\n",(0,a.jsxs)(t.p,{children:["Promises themselves are cluster-scoped and are not namespaced. That means a\nPromise is visible across the cluster once installed. Use Kubernetes RBAC to\ncontrol who can list Promises and who can create request resources in each\nnamespace. See the Kratix ",(0,a.jsx)(t.a,{href:"/main/platform-concepts/auth/rbac",children:"RBAC"})," guide for\nexamples and guidance."]}),"\n",(0,a.jsxs)(t.p,{children:["For the Kubernetes details, see the ",(0,a.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",children:"Namespaces"})," docs."]})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);