"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[5186],{5846:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});var r=i(5893),o=i(1151);const l={description:"Documentation for writing Promise Workflows using Kratix Pipelines, covering how Kratix internally executes the Pipeline containers",title:"Promise Workflows",sidebar_label:"Workflows"},s=void 0,t={id:"main/reference/promises/workflows",title:"Promise Workflows",description:"Documentation for writing Promise Workflows using Kratix Pipelines, covering how Kratix internally executes the Pipeline containers",source:"@site/docs/main/05-reference/04-promises/04-workflows.md",sourceDirName:"main/05-reference/04-promises",slug:"/main/reference/promises/workflows",permalink:"/main/reference/promises/workflows",draft:!1,unlisted:!1,editUrl:"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-reference/04-promises/04-workflows.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{description:"Documentation for writing Promise Workflows using Kratix Pipelines, covering how Kratix internally executes the Pipeline containers",title:"Promise Workflows",sidebar_label:"Workflows"},sidebar:"mainSidebar",previous:{title:"Updates",permalink:"/main/reference/promises/updates"},next:{title:"Versioning",permalink:"/main/reference/promises/releases"}},a={},c=[{value:"Configure Workflows",id:"configure-workflows",level:2},{value:"Multiple Pipelines",id:"multiple-pipelines",level:3},{value:"Pipeline Failures",id:"pipeline-failures",level:3},{value:"Idempotency",id:"idempotency",level:3},{value:"Manual Reconciliation",id:"manual-reconciliation",level:3},{value:"Delete Workflows",id:"delete-workflows",level:2},{value:"Pipeline Failures",id:"pipeline-failures-1",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"A Kratix Promise may contain workflow definitions for hooking into the Promise lifecycle."}),"\n",(0,r.jsxs)(n.p,{children:["Kratix supports two Promise workflow types: ",(0,r.jsx)(n.code,{children:"configure"})," and ",(0,r.jsx)(n.code,{children:"delete"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"configure"})," workflow runs when the Promise is created, updated, or reconciled."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"delete"})," workflow runs when the Promise is deleted."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Kratix workflows are made up of one or more Pipelines."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"configure"})," workflow may contain multiple Pipelines, which are executed serially."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"delete"})," workflow can only contain a single Pipeline."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Refer to the ",(0,r.jsx)(n.a,{href:"../workflows",children:"Workflows documentation"})," for details on ",(0,r.jsx)(n.strong,{children:"how to\nwrite Kratix Pipelines"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["To define Promise workflows inside a Promise, use ",(0,r.jsx)(n.code,{children:"spec.workflows.promise"})," in the Promise\ndefinition as shown below."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"platform: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  ...\nspec:\n  ...\n  workflows:\n    promise:\n      configure:\n        - # Pipeline definitions (multiple)\n      delete:\n        - # Pipeline definition (single)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configure-workflows",children:"Configure Workflows"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"configure"})," workflow runs when the Promise is created, updated, or reconciled."]}),"\n",(0,r.jsx)(n.h3,{id:"multiple-pipelines",children:"Multiple Pipelines"}),"\n",(0,r.jsxs)(n.p,{children:["Promise Configure workflows allow for ",(0,r.jsx)(n.strong,{children:"multiple"})," Pipelines to be executed in sequence."]}),"\n",(0,r.jsx)(n.p,{children:"This enables step-by-step configuration of declarative state, as each Pipeline ends by\nwriting its output to the Kratix State Store. This means each Pipeline can depend upon\nstate declared during the previous Pipelines."}),"\n",(0,r.jsx)(n.p,{children:"Within each Pipeline, an array of containers are defined, which will also execute in\nsequence."}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"For simple cases, a single Pipeline with one or many containers will suffice."})}),"\n",(0,r.jsxs)(n.p,{children:["The example below shows how a ",(0,r.jsx)(n.code,{children:"promise.configure"})," workflow can be defined:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"platform: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  ...\nspec:\n  ...\n  workflows:\n    promise:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: pipeline-a # Executes first\n          spec:\n            containers:\n              ...\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: pipeline-b # Follows pipeline-a\n          spec:\n            containers:\n              ...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In this example, ",(0,r.jsx)(n.code,{children:"pipeline-a"})," will run first, followed by ",(0,r.jsx)(n.code,{children:"pipeline-b"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-failures",children:"Pipeline Failures"}),"\n",(0,r.jsxs)(n.p,{children:["A Pipeline fails if any of its ",(0,r.jsx)(n.code,{children:"containers"})," return a non-zero exit code."]}),"\n",(0,r.jsxs)(n.p,{children:["If this occurs, the workflow ",(0,r.jsx)(n.strong,{children:"halts"}),": no further containers are executed within the\nPipeline, and no further Pipelines are executed in the workflow."]}),"\n",(0,r.jsxs)(n.p,{children:["To re-run a workflow following a Pipeline failure, you can perform a\n",(0,r.jsx)(n.a,{href:"#manual-reconciliation",children:"manual reconciliation"})," of the Promise, which will trigger the\nworkflow again from the beginning."]}),"\n",(0,r.jsx)(n.h3,{id:"idempotency",children:"Idempotency"}),"\n",(0,r.jsx)(n.p,{children:"All commands which run in Configure workflows must be idempotent, as there is a guarantee\nthat they will be run multiple times a day, and may be run much more frequently depending\non other environmental impacts (e.g. Pod restarts)."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"promise.configure"})," workflow is regularly executed. Kubernetes reconciles on a number\ndifferent actions, including, but not limited to:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Promise creation"}),"\n",(0,r.jsx)(n.li,{children:"Regular interval (10 hours, not currently configurable)"}),"\n",(0,r.jsx)(n.li,{children:"Kratix Controller restarts"}),"\n",(0,r.jsx)(n.li,{children:"Changes to the Promise definition"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"manual-reconciliation",children:"Manual Reconciliation"}),"\n",(0,r.jsx)(n.p,{children:"Sometimes you may wish to manually trigger a Configure workflow for a specific Promise."}),"\n",(0,r.jsx)(n.p,{children:"In addition to the standard triggers outlined above, a Promise can be manually triggered\nfor reconciliation by labelling it as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'kratix.io/manual-reconciliation: "true"\n'})}),"\n",(0,r.jsx)(n.p,{children:"This will trigger the Promise Configure workflow to run."}),"\n",(0,r.jsx)(n.p,{children:"This workflow instance will terminate any in-progress Promise Configure workflow and start\nagain from the first Pipeline."}),"\n",(0,r.jsx)(n.p,{children:"Once Kratix schedules the manual workflow, the label will be removed, allowing you to add\nit again for any additional manual runs."}),"\n",(0,r.jsxs)(n.p,{children:["See below for an example command to trigger a manual reconciliation of a ",(0,r.jsx)(n.code,{children:"redis"})," Promise."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"kubectl label promises.platform.kratix.io redis kratix.io/manual-reconciliation=true\n"})}),"\n",(0,r.jsx)(n.h2,{id:"delete-workflows",children:"Delete Workflows"}),"\n",(0,r.jsxs)(n.p,{children:["Promise Delete workflows are triggered when a Promise is deleted, and currently only\nsupport a ",(0,r.jsx)(n.strong,{children:"single"})," Pipeline."]}),"\n",(0,r.jsxs)(n.p,{children:["This Pipeline is responsible for cleaning up resources and configurations that were set up\nby the ",(0,r.jsx)(n.code,{children:"promise.configure"})," workflow."]}),"\n",(0,r.jsxs)(n.p,{children:["The example below shows how a ",(0,r.jsx)(n.code,{children:"promise.delete"})," workflow can be defined."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"platform: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  ...\nspec:\n  ...\n  workflows:\n    promise:\n      delete:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: delete-pipeline # Single pipeline\n          spec:\n            containers:\n              ...\n"})}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-failures-1",children:"Pipeline Failures"}),"\n",(0,r.jsx)(n.p,{children:"Kratix will trigger the Delete Pipeline exactly once."}),"\n",(0,r.jsxs)(n.p,{children:["If a command fails during container execution, this must be handled ",(0,r.jsx)(n.strong,{children:"within the container\nitself"})," (including any retry attempts)."]}),"\n",(0,r.jsx)(n.p,{children:"Kratix will not reschedule/retry any Pipelines which have failed as part of a Delete\nworkflow."})]})}function p(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>t,a:()=>s});var r=i(7294);const o={},l=r.createContext(o);function s(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);