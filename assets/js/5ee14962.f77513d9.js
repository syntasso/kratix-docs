"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[898],{28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var s=i(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},46559:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>l,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"main/guides/upgrading-resource-requests","title":"Upgrading a Promise","description":"A guide to upgrading Promises and resource requests with PromiseRevisions and ResourceBindings","source":"@site/docs/main/04-guides/06-upgrading-resource-requests.mdx","sourceDirName":"main/04-guides","slug":"/main/guides/upgrading-resource-requests","permalink":"/main/guides/upgrading-resource-requests","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/04-guides/06-upgrading-resource-requests.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"description":"A guide to upgrading Promises and resource requests with PromiseRevisions and ResourceBindings","title":"Upgrading a Promise","keywords":["promise upgrades","resource upgrades","resource bindings","promise bindings","versioning","updates"]},"sidebar":"mainSidebar","previous":{"title":"Compound Promises","permalink":"/main/guides/compound-promises"},"next":{"title":"Adding a new Destination","permalink":"/main/guides/new-destination"}}');var r=i(74848),o=i(28453);const a={description:"A guide to upgrading Promises and resource requests with PromiseRevisions and ResourceBindings",title:"Upgrading a Promise",keywords:["promise upgrades","resource upgrades","resource bindings","promise bindings","versioning","updates"]},t=void 0,d={},c=[{value:"Updating the API",id:"updating-the-api",level:2},{value:"Updates to Workflows",id:"updates-to-workflows",level:2},{value:"Upgrading Resource Requests",id:"upgrading-resource-requests",level:2},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Kratix Promises provide a means of providing Anything-as-a-Service. The Promise\nAPI equips users with the ability to tailor a given service to their needs.\nEssential business rules can be embedded within Promise workflows and the\ncontinuous reconciliation of resources helps ensure resources are kept\nup-to-date."}),"\n","\n","\n",(0,r.jsx)(n.p,{children:"During an upgrade, any part of the Promise can change:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The API"}),"\n",(0,r.jsx)(n.li,{children:"The Dependencies"}),"\n",(0,r.jsx)(n.li,{children:"The Workflows"}),"\n",(0,r.jsx)(n.li,{children:"The Destination Selectors"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Kratix applies the following rules when upgrading a Promise:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Changes to the API are left to Kubernetes"}),"\n",(0,r.jsx)(n.li,{children:"Promises have Revisions"}),"\n",(0,r.jsx)(n.li,{children:"Destinations are always on the latest installed Promise Revision"}),"\n",(0,r.jsx)(n.li,{children:"Resource requests are associated to a Promise Revision"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This guide will illustrate how you could control how and when resource requests are upgraded when a new version of a Promise is installed."}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["Promise Revisions and Resource Bindings are still a beta feature. To enable it, you must set the ",(0,r.jsx)(n.code,{children:"promiseUpgrade"})," feature flag to true in the ",(0,r.jsx)(n.a,{href:"/main/reference/kratix-config/config",children:"Kratix Config"})]})}),"\n",(0,r.jsx)(n.h2,{id:"updating-the-api",children:"Updating the API"}),"\n",(0,r.jsx)(n.p,{children:"When introducing changes to Promise API, it is essential to ensure that the changes are backwards-compatible.\nFor instance, when a Resource Configure workflow runs for the updated Promise, it should not fail because of a newly-introduced change to the API."}),"\n",(0,r.jsxs)(n.p,{children:["Let's say we have an ",(0,r.jsx)(n.code,{children:"app"})," promise, and we want to introduce the ability to configure a database.\nWhen selecting a database, consumers should be able to configure a size of ",(0,r.jsx)(n.code,{children:"small"}),", ",(0,r.jsx)(n.code,{children:"medium"})," or ",(0,r.jsx)(n.code,{children:"large"}),".\nThis new configurability can be added to the API by introducing a new field, like:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"spec: # Promise spec\n  api:\n    schema:\n      openAPIV3Schema:\n        type: object\n        properties:\n          spec:\n            type: object\n            ...\n            properties:\n              #highlight-start\n              dbSize:\n                type: string\n              #highlight-end\n"})}),"\n",(0,r.jsx)(n.p,{children:"This is a backwards-compatible change, as introducing a new field should not cause issues when the field is not present.\nIf your updates to the API include changes such as changing the type of an existing field,\nmaking an existing field required, or removing a field, these could be breaking\nchanges to your API contract and your API is no longer backwards-compatible.\nIntroducing a new API group and adding a conversion webhook will be required to support breaking changes to the API."}),"\n",(0,r.jsx)(n.h2,{id:"updates-to-workflows",children:"Updates to Workflows"}),"\n",(0,r.jsxs)(n.p,{children:["With the new field ",(0,r.jsx)(n.code,{children:"spec.dbSize"})," added to our Promise API, we would like to start using it in our workflow to deploy a database for our applications."]}),"\n",(0,r.jsx)(n.p,{children:"However, we don't want existing resource requests to be impacted by this new feature of the Promise."}),"\n",(0,r.jsxs)(n.p,{children:["This is where ",(0,r.jsx)(n.a,{href:"/main/reference/promises/promise-upgrade/promise-revisions",children:"Promise Revisions"})," and ",(0,r.jsx)(n.a,{href:"/main/reference/promises/promise-upgrade/resource-bindings",children:"Resource Bindings"})," come into play. Promise Revisions track different versions of a Promise, and the Resource Bindings control the version of the Promise that a resource request was created from."]}),"\n",(0,r.jsx)(n.p,{children:"For example, given our app Promise:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  labels:\n    kratix.io/promise-version: v0.0.1\n  name: app\nspec:\n  api:\n    apiVersion: apiextensions.k8s.io/v1\n    kind: CustomResourceDefinition\n    metadata:\n      name: apps.workshop.kratix.io\n    spec:\n      group: workshop.kratix.io\n      names:\n        kind: App\n        plural: apps\n        singular: app\n      scope: Namespaced\n      versions:\n        - name: v1\n          schema:\n            openAPIV3Schema:\n              properties:\n                spec:\n                  properties:\n                    image:\n                      type: string\n                  type: object\n              type: object\n          served: true\n          storage: true\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: mypipeline\n          spec:\n            containers:\n              - command:\n                  - resource-configure\n                image: kratix-workshop/app-pipeline-image:v1.0.0\n                name: kratix-workshop-app-pipeline-image\n"})}),"\n",(0,r.jsxs)(n.p,{children:["We would like to introduce ",(0,r.jsx)(n.code,{children:".spec.dbSize"})," to the Promise API, and add a new container to the existing Resource Configure\nworkflow pipeline to deploy a database for the application. The updated promise would look like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  labels:\n    #highlight-start\n    kratix.io/promise-version: v0.0.2 # new Promise version\n    #highlight-end\n  name: app\nspec:\n  api:\n    apiVersion: apiextensions.k8s.io/v1\n    kind: CustomResourceDefinition\n    metadata:\n      name: apps.workshop.kratix.io\n    spec:\n      group: workshop.kratix.io\n      names:\n      ...\n      scope: Namespaced\n      versions:\n        - name: v1\n          schema:\n            openAPIV3Schema:\n              properties:\n                spec:\n                  properties:\n                    #highlight-start\n                    dbDriver: # new API field\n                      type: string\n                    #highlight-end\n                    image:\n                      type: string\n                  type: object\n              type: object\n          served: true\n          storage: true\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: mypipeline\n          spec:\n            containers:\n              - name: kratix-workshop-app-pipeline-image\n                command: [resource-configure]\n                image: kratix-workshop/app-pipeline-image:v1.0.0\n              #highlight-start\n              - name: database-configure # new container to deploy a database\n                image: kratix-workshop/app-pipeline-image:v1.0.0\n                command: [ database-configure ]\n              #highlight-end\n"})}),"\n",(0,r.jsx)(n.p,{children:"After applying this new version of our app Promise, we should see two Promise Revisions created in our environment:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl get promiserevisions\nNAME         LATEST\napp-v0.0.1\napp-v0.0.2   true\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You can see that the version ",(0,r.jsx)(n.code,{children:"v0.0.2"})," is being marked as the latest Promise Revision. New app resource requests will be automatically bound to the ",(0,r.jsx)(n.code,{children:"v0.0.2"})," version, which includes our changes to the Promise API and the new container in the Resource Configure workflow. For any existing resource requests, if you check their Resource Bindings, you can see that they continue to be bound to the previous Promise Revision:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: ResourceBinding\nmetadata:\n  labels:\n    kratix.io/promise-name: app\n    kratix.io/resource-name: app-a\n  name: app-a-c42a2\n  namespace: default\nspec:\n  promiseRef:\n    name: app\n  resourceRef:\n    name: app-a\n    namespace: default\n  version: v0.0.1\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This application will continue to be reconciled at Promise Revision ",(0,r.jsx)(n.code,{children:"app-v0.0.1"})," until we update the Promise version in its Resource Binding."]}),"\n",(0,r.jsxs)(n.p,{children:["Another way that we can ensure that the addition of the workflow does not deploy any unexpected database for existing resources is via the\n",(0,r.jsx)(n.code,{children:"database-configure"})," container itself. The script run within the container can guard against the property being absent from the resource request. Take to following example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import kratix_sdk as ks\nimport yaml\n\n# Initialize the sdk\nsdk = ks.KratixSDK()\nresource = sdk.read_resource_input()\n\n# Read from resource input\ndbSize = resource.get_value("spec.dbSize", default="not-set")\n\nif dbSize == "not-set"\n    print("no dbSize configured, skipping database deployment")\n    exit(0)\n\n# ...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["If the Resource Configure Workflow runs for a resource request which does not have a ",(0,r.jsx)(n.code,{children:"dbSize"})," in it's spec, the script above will exit early. This means that if a user ",(0,r.jsx)(n.em,{children:"did"})," update their Resource Binding to a Promise Version where the ",(0,r.jsx)(n.code,{children:"database-configure"})," container ran, it wouldn't fail or deploy any unexpected database."]}),"\n",(0,r.jsx)(n.h2,{id:"upgrading-resource-requests",children:"Upgrading Resource Requests"}),"\n",(0,r.jsxs)(n.p,{children:["To upgrade a resource request that is bound to a previous Promise Revision, you can edit the existing Resource Binding ",(0,r.jsx)(n.code,{children:"spec.version"})," and point it to the desired Promise Revision version. In our example, we had a resource request bound to ",(0,r.jsx)(n.code,{children:"v0.0.1"}),". To upgrade it, edit it as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: ResourceBinding\nmetadata:\n  labels:\n    kratix.io/promise-name: app\n    kratix.io/resource-name: app-a\n  name: app-a-c42a2\n  namespace: default\nspec:\n  promiseRef:\n    name: app\n  resourceRef:\n    name: app-a\n    namespace: default\n  # highlight-next-line\n  version: v0.0.2 # changed from v0.0.1 to v0.0.2\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once that change is applied, Kratix will run the Resource Configure Workflow for the target resource using the ",(0,r.jsx)(n.code,{children:"v0.0.2"})," Promise Revision."]}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Promise Revisions and Resource Bindings enable resources to be associated with different versions of a Promise, which allows the platform engineering team to control exactly when and how the fleet will be upgraded. This, together with health checks, allow more controlled upgrades in production environments."}),"\n",(0,r.jsxs)(n.p,{children:["We hope this guide has given you a better understanding of how to control upgrades. If you have any questions or feedback please don't hesitate to reach out to us on ",(0,r.jsx)(n.a,{href:"https://kratixworkspace.slack.com/",children:"Slack"})," or ",(0,r.jsx)(n.a,{href:"https://github.com/syntasso/kratix",children:"GitHub"}),"."]})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);