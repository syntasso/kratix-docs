"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[2716],{2497:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"ske/guides/healthchecks","title":"Health checks","description":"Implementing Resource Health Checks","source":"@site/docs/ske/05-guides/10-healthchecks.mdx","sourceDirName":"ske/05-guides","slug":"/ske/guides/healthchecks","permalink":"/ske/guides/healthchecks","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/ske/05-guides/10-healthchecks.mdx","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"Health checks","description":"Implementing Resource Health Checks","sidebar_label":"Health Checks"},"sidebar":"skeSidebar","previous":{"title":"Guides","permalink":"/category/guides-1"},"next":{"title":"Health Checks for non Kubernetes Resources","permalink":"/ske/guides/healthchecks-nonk8s"}}');var a=t(4848),s=t(8453),r=t(2546);const o={title:"Health checks",description:"Implementing Resource Health Checks",sidebar_label:"Health Checks"},l=void 0,h={},c=[{value:"Pre-requisites",id:"pre-requisites",level:2},{value:"How do Health Checks work in SKE?",id:"how-do-health-checks-work-in-ske",level:2},{value:"Generate a Health Definition",id:"generate-hd",level:2},{value:"Writing a Health Check Workflow",id:"write-hc",level:2},{value:"Verify the results",id:"observe-hc-result",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"pre-requisites",children:"Pre-requisites"}),"\n",(0,a.jsxs)(n.p,{children:["You will need an installation of SKE for this section. Go to ",(0,a.jsx)(n.a,{href:"../kratix/configuring-ske/intro",children:"Configuring SKE"})," and follow the appropriate guide if you haven't done so already."]}),"\n",(0,a.jsxs)(n.p,{children:["You will also need a configured and deployed Health Agent. You can do that by following the guide on ",(0,a.jsx)(n.a,{href:"../kratix/ske-health-agent",children:"Configuring the Kubernetes Health Agent"}),"."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"In this tutorial you will"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#generate-hd",children:"Generate a Health Definition in the Resource Workflow"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#write-hc",children:"Write a Health Check Workflow"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"#observe-hc-result",children:"Verify the results"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"how-do-health-checks-work-in-ske",children:"How do Health Checks work in SKE?"}),"\n",(0,a.jsxs)(n.p,{children:["Health Checks are implemented in SKE via ",(0,a.jsx)(n.code,{children:"HealthDefinition"})," objects. A Health Definition is the outline of the task that will be performed on a Destination to verify the health of a Resource Request."]}),"\n",(0,a.jsx)(n.p,{children:"The diagram below shows how Health Checks are processed in SKE:"}),"\n","\n",(0,a.jsxs)("figure",{className:"diagram",children:[(0,a.jsx)("img",{className:"large",src:r.A,alt:"High-level diagram of how Health Check works in Kratix"}),(0,a.jsx)("figcaption",{children:"How Health Checks are processed in SKE"})]}),"\n",(0,a.jsx)(n.p,{children:"Let's go through the diagram in detail:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"When a new resource is requested from a Promise, Kratix will do the usual and execute the Resource Configure Workflow for that Promise."}),"\n",(0,a.jsxs)(n.li,{children:["As part of the outputs of that workflow, you can include a ",(0,a.jsx)(n.code,{children:"HealthDefinition"})," object, including all the necessary information to execute the Health Check Workflow on the Destination."]}),"\n",(0,a.jsxs)(n.li,{children:["Once that HealthDefinition is picked up and applied at the target Destination, the Health Check agent will execute the Health Check Workflow and produce a ",(0,a.jsx)(n.code,{children:"HealthRecord"})," document."]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"HealthRecord"})," is then written to a State Store,"]}),"\n",(0,a.jsxs)(n.li,{children:["The ",(0,a.jsx)(n.code,{children:"HealthRecord"})," is then applied back to the Platform cluster via a GitOps agent listening to the State Store."]}),"\n",(0,a.jsxs)(n.li,{children:["The Health Check monitor within SKE will then process the ",(0,a.jsx)(n.code,{children:"HealthRecord"})," and update the resource ",(0,a.jsx)(n.code,{children:"status"})," with the results."]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"You will need to set up the Health Agent (and its CRDs) on all Destinations that can run Health Checks."})}),"\n",(0,a.jsx)(n.p,{children:"With that in mind, let's get started!"}),"\n",(0,a.jsx)(n.h2,{id:"generate-hd",children:"Generate a Health Definition"}),"\n",(0,a.jsx)(n.p,{children:"In this tutorial, you will define a Resource Health Check for the Redis Promise available in the Kratix Marketplace."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"/ske/api-reference/healthdefinition",children:"HealthDefinition"})," object has the following specification:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: HealthDefinition\nmetadata:\n  name: # unique name for the health definition\n  namespace: # the healthdefinition namespace\nspec:\n  resourceRef:\n    name: # the resource name\n    namespace: # the resource namespace\n\n  promiseRef:\n    name: # the name of the promise\n\n  schedule: #cronjob schedule\n\n  input: # the inputs the workflow needs\n\n  workflow: # a Kratix Pipeline\n"})}),"\n",(0,a.jsx)(n.p,{children:"In order to define a Resource Health Check, we will need to add a new container to the Resource Configure Workflow to generate the appropriate HealthDefinition."}),"\n",(0,a.jsx)(n.p,{children:"A very basic Resource Health Definition for the Redis Promise could look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'resourceName=$(yq \'.metadata.name\' /kratix/input/object.yaml)\nnamespace="$(yq \'.metadata.namespace // "default"\' /kratix/input/object.yaml)"\npromiseName="redis"\n\ncat <<EOF > /kratix/output/health-definition.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: HealthDefinition\nmetadata:\n  name: ${promiseName}-${resourceName}-${namespace} # this name needs to be unique\n  namespace: default # this can be any namespace that exists in the Destination\nspec:\n  resourceRef:\n    name: ${resourceName}\n    namespace: ${namespace}\n  promiseRef:\n    name: ${promiseName}\n  schedule: "* * * * *" # runs every minute: https://crontab.guru/#*_*_*_*_*\n  input: |\n    name: ${resourceName}\n  workflow:\n    apiVersion: platform.kratix.io/v1alpha1\n    kind: Pipeline\n    metadata:\n      name: healthcheck\n    spec:\n      containers:\n      - image: busybox # this is a placeholder image, we will update this later with our own health check\n        name: check-redis\nEOF\n'})}),"\n",(0,a.jsxs)(n.p,{children:["As you can see, the Health Definition is being persistent in ",(0,a.jsx)(n.code,{children:"/kratix/output"})," as a file called ",(0,a.jsx)(n.code,{children:"health-definition.yaml"}),". Right now, it's not doing anything useful, but it should be enough to test the end-to-end wiring of the Health Check systems. For simplicity, we made the script above available in the ",(0,a.jsx)(n.code,{children:"ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0"})," image as ",(0,a.jsx)(n.code,{children:"basic-definition"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["You can build your own container image if you want. The process is similar to the one described in the ",(0,a.jsx)(n.a,{href:"/main/guides/writing-a-promise",children:"Writing a Promise"})," guide."]})}),"\n",(0,a.jsx)(n.p,{children:"To include it in the Redis Promise, first download the Promise file to your local machine:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"curl -Lo redis-promise.yaml https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/redis/promise.yaml\n"})}),"\n",(0,a.jsx)(n.p,{children:"Next, locate the Resource Configure Workflow and add a new container to it:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: redis\n  labels:\n    kratix.io/promise-version: v0.1.0\nspec:\n  api: # omitted for brevity\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: instance-configure\n          spec:\n            containers:\n              - image: ghcr.io/syntasso/kratix-marketplace/redis-configure-pipeline:v0.1.0\n                name: redis-configure-pipeline\n              #highlight-start\n              - image: ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0\n                name: generate-healthdefinition\n                command: [ "basic-definition" ]\n              #highlight-end\n    promise: # omitted for brevity\n'})}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsxs)(n.p,{children:["Make sure you add the container to the correct location in the Promise. The container needs to be added to the ",(0,a.jsx)(n.code,{children:"resource.configure"})," section, so that it is executed when a Resource Request is applied."]})}),"\n",(0,a.jsx)(n.p,{children:"You can now apply the updated Promise:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM apply -f redis-promise.yaml\n"})}),"\n",(0,a.jsx)(n.p,{children:"Once the Promise is applied, you can send a Resource Request:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM apply -f https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/redis/resource-request.yaml\n"})}),"\n",(0,a.jsx)(n.p,{children:"At this stage, Kratix should execute the Resource Configure Workflow as expected in the Platform cluster:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $PLATFORM get pods\nNAME                                                  READY   STATUS      RESTARTS   AGE\nkratix-redis-example-instance-configure-523d9-blr7b   0/1     Completed   0          10s\n"})}),"\n",(0,a.jsx)(n.p,{children:"If you inspect the State Store, you should see a new Health Definition file there. On the Destination, you should see the new HealthDefinition object getting applied:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $WORKER get healthdefinitions\nNAME                    AGE\nredis-example-default   10s\n"})}),"\n",(0,a.jsx)(n.p,{children:"The SKE Health Agent running in the Destination will react to the new HealthDefinition and schedule a CronJob to run the Health Check Workflow. You can check the CronJob (it may take a couple of minutes):"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $WORKER get cronjobs\nNAMESPACE   NAME                                      SCHEDULE    TIMEZONE   SUSPEND   ACTIVE   LAST SCHEDULE   AGE\ndefault     healthcheck-redis-default-example-78709   * * * * *   <none>     False     1        1s              1m\n"})}),"\n",(0,a.jsx)(n.p,{children:"The CronJob will eventually execute the Workflow defined in the HealthDefinition (you may need to wait a minute or two for it to appear). Eventually, you should see the pod running the Health Check Workflow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $WORKER get pods\nNAME                                                     READY   STATUS      RESTARTS   AGE\nhealthcheck-redis-default-example-78709-28947857-8t6b5   0/1     Completed   0          39s\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"Since the health check is schedule to run every minute, if you keep watching the pods, you should see new ones starting at the turn of each minute."})}),"\n",(0,a.jsxs)(n.p,{children:["Since the workflow completed successfully, the SKE Health Agent running in your Destination should have written a ",(0,a.jsx)(n.code,{children:"HealthRecord"})," to the State Store. Since you have a GitOps agent listening to that State Store, the Health Record will be applied back to the Platform cluster."]}),"\n",(0,a.jsx)(n.p,{children:"At this stage, you should see the Health check results in your Redis resource:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get redis.marketplace.kratix.io example -oyaml\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Towards the end, under ",(0,a.jsx)(n.code,{children:"status"}),", you should see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"status:\n  healthRecord:\n    state: healthy\n"})}),"\n",(0,a.jsx)(n.p,{children:"Great! That proves the Health Check is working end-to-end."}),"\n",(0,a.jsx)(n.p,{children:"However, the Health Check workflow itself is not quite checking anything. Let's fix that."}),"\n",(0,a.jsx)(n.h2,{id:"write-hc",children:"Writing a Health Check Workflow"}),"\n",(0,a.jsxs)(n.p,{children:["When you define a Health Check, you are basically telling SKE to execute a task on the Destination to validate the health of the resource. Similar to how you define a Resource Workflow to instantiate a Resource, you will define a Kratix ",(0,a.jsx)(n.code,{children:"Pipeline"})," to determine the resource health."]}),"\n",(0,a.jsx)(n.p,{children:"But what does it mean for a resource of a Promise to be healthy? This is for you to define: different promises will have different definitions. Let's take a closer look at the Redis Promise."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/syntasso/kratix-marketplace/blob/main/redis/internal/configure-pipeline/resources/redis-instance.yaml",children:"Redis Resource Configure Workflow"})," outputs a ",(0,a.jsx)(n.code,{children:"RedisFailover"})," resource. This resource is picked up by the Redis Operator, and a series of other resources are created, including a StatefulSet that will be used to provide the Redis service. To validate the health of the resource, we could check if the StatefulSet has the same number of replicas as ready replicas."]}),"\n",(0,a.jsxs)(n.p,{children:["The Redis promise generates deterministic names for the Redis resources, based on the Object ",(0,a.jsx)(n.code,{children:"metadata.name"}),". The StatefulSet, in particular, is named as ",(0,a.jsx)(n.code,{children:"rfr-$resourceName"}),", where ",(0,a.jsx)(n.code,{children:"resourceName"})," is the name of the Redis resource. Similar to the Resource Configure Workflow, your container will have access to a file ",(0,a.jsx)(n.code,{children:"/kratix/input/object.yaml"})," with the contents of the ",(0,a.jsx)(n.code,{children:"spec.input"})," you defined in the Health Definition. If you go back, you will see we are already defining a ",(0,a.jsx)(n.code,{children:"name: ${resourceName}"})," in the ",(0,a.jsx)(n.code,{children:"input"})," field. All we need to do is read that value and use it to get the StatefulSet."]}),"\n",(0,a.jsx)(n.p,{children:"With that in hand, we can write the following Health Check Workflow:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",metastring:'title="script to be executed in the destination"',children:"resourceName=$(yq '.name' /kratix/input/object.yaml)\n\n# Get the Redis statefulset generated from the Resource Request\nreplicas=$(kubectl -n default get statefulsets rfr-${resourceName} -o jsonpath='{.status.replicas}')\nreadyReplicas=$(kubectl -n default get statefulsets rfr-${resourceName} -o jsonpath='{.status.readyReplicas}')\n\nstate=\"unhealthy\"\n\nif [[ ${replicas} -eq ${readyReplicas} ]]; then\n  state=\"healthy\"\nfi\n\ncat <<EOF > /kratix/output/health-status.yaml\nstate: ${state}\ndetails:\n  replicas: ${replicas}\n  readyReplicas: ${readyReplicas}\nEOF\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can create a Container image and add this script to it. To keep the scope of this tutorial simple, we have packaged it into the ",(0,a.jsx)(n.code,{children:"ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0"})," image, under the ",(0,a.jsx)(n.code,{children:"check-redis"})," command. All we need to do is update the script that's generating the HealthDefinition to use the image and command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",metastring:'title="script to be executed in the platform"',children:'resourceName=$(yq \'.metadata.name\' /kratix/input/object.yaml)\nnamespace="$(yq \'.metadata.namespace // "default"\' /kratix/input/object.yaml)"\npromiseName="redis"\n\ncat <<EOF > /kratix/output/health-definition.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: HealthDefinition\nmetadata:\n  name: ${promiseName}-${resourceName}-${namespace}\n  namespace: default\nspec:\n  resourceRef:\n    name: ${resourceName}\n    namespace: ${namespace}\n  promiseRef:\n    name: ${promiseName}\n  # runs every minute\n  schedule: "* * * * *"\n  input: |\n    name: ${resourceName}\n  workflow:\n    apiVersion: platform.kratix.io/v1alpha1\n    kind: Pipeline\n    metadata:\n      name: healthcheck\n    spec:\n      containers:\n      #highlight-start\n      - image: ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0\n        name: check-redis\n        command: [ "check-redis" ]\n      #highlight-end\nEOF\n'})}),"\n",(0,a.jsxs)(n.p,{children:["There's one more change you'll need to make to the Workflow defined in the HealthDefinition: define the RBAC permissions. By default, the Health Check Pipeline Stage will not have access to much of the Kubernetes API; if you try to execute the Health check as defined above, the workflow will fail when it tries to ",(0,a.jsx)(n.code,{children:"kubectl get"})," the StatefulSet."]}),"\n",(0,a.jsx)(n.p,{children:"To fix this, you need to add the following RBAC permissions to the Workflow in your HealthDefinition:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'rbac:\n  permissions:\n  - apiGroups: ["apps"]\n    verbs: ["get"]\n    resources: ["statefulsets"]\n'})}),"\n",(0,a.jsx)(n.p,{children:"The updated script will look like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'resourceName=$(yq \'.metadata.name\' /kratix/input/object.yaml)\nnamespace="$(yq \'.metadata.namespace // "default"\' /kratix/input/object.yaml)"\npromiseName="redis"\n\ncat <<EOF > /kratix/output/health-definition.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: HealthDefinition\nmetadata:\n  name: ${promiseName}-${resourceName}-${namespace}\n  namespace: default\nspec:\n  resourceRef:\n    name: ${resourceName}\n    namespace: ${namespace}\n  promiseRef:\n    name: ${promiseName}\n  # runs every minute\n  schedule: "* * * * *"\n  input: |\n    name: ${resourceName}\n  workflow:\n    apiVersion: platform.kratix.io/v1alpha1\n    kind: Pipeline\n    metadata:\n      name: healthcheck\n    spec:\n      #highlight-start\n      rbac:\n        permissions:\n        - apiGroups: ["apps"]\n          verbs: ["get"]\n          resources: ["statefulsets"]\n      #highlight-end\n      containers:\n      - image: ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0\n        name: check-redis\n        command: [ "check-redis" ]\nEOF\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Once again, we packaged the script above in the ",(0,a.jsx)(n.code,{children:"ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0"})," image, under the ",(0,a.jsx)(n.code,{children:"complete-definition"})," command."]}),"\n",(0,a.jsx)(n.p,{children:"Open your Redis Promise and update the container to use the new image and command:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: redis\n  labels:\n    kratix.io/promise-version: v0.1.0\nspec:\n  api: # omitted for brevity\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: instance-configure\n          spec:\n            containers:\n              - image: ghcr.io/syntasso/kratix-marketplace/redis-configure-pipeline:v0.1.0\n                name: redis-configure-pipeline\n              #highlight-start\n              - image: ghcr.io/syntasso/kratix-docs/redis-health-checks:v0.1.0\n                name: generate-healthdefinition\n                command: [ "complete-definition" ]\n              #highlight-end\n    promise: # omitted for brevity\n'})}),"\n",(0,a.jsx)(n.p,{children:"You can now apply the updated Promise:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM apply -f redis-promise.yaml\n"})}),"\n",(0,a.jsx)(n.p,{children:"This should automatically trigger the Resource Workflow and apply the new HealthDefinition on the Destination."}),"\n",(0,a.jsx)(n.h2,{id:"observe-hc-result",children:"Verify the results"}),"\n",(0,a.jsx)(n.p,{children:"With the new Health Definition, the CronJob on the Destination will eventually be updated with the new Health Check Workflow. At the turn of the minute, you should observe new pod starting:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"$ kubectl --context $WORKER get pods\nNAME                                                     READY   STATUS      RESTARTS   AGE\nhealthcheck-redis-default-example-78709-28951821-dgszb   0/1     Completed   0          2m25s\nhealthcheck-redis-default-example-78709-28951822-nsx9q   0/1     Completed   0          85s\nhealthcheck-redis-default-example-78709-28951823-2wcls   0/1     Completed   0          25s\n"})}),"\n",(0,a.jsx)(n.p,{children:"Once it completes, you should now see the Health check results in your Redis resource:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM get redis.marketplace.kratix.io example -oyaml\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsx)(n.p,{children:"It may take a couple of minutes for the Resource status to update"})}),"\n",(0,a.jsxs)(n.p,{children:["Towards the end, under ",(0,a.jsx)(n.code,{children:"status"}),", you should see the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"status:\n  healthRecord:\n    state: healthy\n    details:\n      replicas: 1\n      readyReplicas: 1\n"})}),"\n",(0,a.jsx)(n.p,{children:"That's it! You've successfully implemented a Resource Health Check!"})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},2546:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/guide-healthcheck-arch-5f1f9d697aecb27b28d3487eb7eb8182.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);