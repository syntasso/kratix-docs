"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[5166],{11312:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var s=t(70929),i=t(74848),a=t(28453);const r=t.p+"assets/images/app-dd3c70a8fb7150e1705e03b0415a401f.png",o={slug:"debugging-promise-updates",title:"Debugging in Kratix",description:"Identifying the tools you can use to debug your Promise rollouts",authors:["sapphire"],tags:["kratix","kratix internals","debugging"]},l=void 0,c={authorsImageUrls:[void 0]},d=[{value:"The end goal",id:"the-end-goal",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Debugging Scheduling in Kratix",id:"debugging-scheduling-in-kratix",level:2},{value:"Identifying invalid workflows",id:"identifying-invalid-workflows",level:2},{value:"Overview",id:"overview",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"As much as we would all like, rolling out updates to any software can result in some bumps along the way. This applies to updates to Promises too but Kratix has some feature to help identify any issues within your Promise spec, your Promise workflows and the scheduling of documents outputted by your workflows."}),"\n",(0,i.jsx)(n.p,{children:"In this blog post we'll explore some of the common issues that users experience when configuring Kratix and developing Promises and well as how Kratix tries to steer you in the right direction when something goes wrong. We'll be exploring:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Querying Kratix effectively with labels"}),"\n",(0,i.jsx)(n.li,{children:"Debugging scheduling issues Kratix"}),"\n",(0,i.jsx)(n.li,{children:"Getting information from Destination and State Store status updates"}),"\n",(0,i.jsx)(n.li,{children:"Validating the Kratix Promise spec"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:'Click on "read more" to continue!'}),"\n","\n",(0,i.jsx)(n.h2,{id:"the-end-goal",children:"The end goal"}),"\n",(0,i.jsx)(n.p,{children:"We'll be working with the Runtime Promise which deploys a Deployment configured with Nginx. By making updates to the Promise and Kratix resources, we'll highlight some common problems and the breadcrumbs you can follow to solve them."}),"\n",(0,i.jsxs)(n.p,{children:["You can follow the steps in this post and debug in your own environment. If you want to do this, start with the Runtime Promise ",(0,i.jsx)(n.a,{href:"https://github.com/syntasso/kratix-docs/tree/main/assets/runtime-promise",children:"here"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"A central property someone making a request of this Promise needs to provide is the image for their Deployment. To optimise this Promise, we want to add a new Pipeline step that performs a security scan of the provided image and outputs the result as a HealthRecord in Kratix. To get started, we'll deploy the Promise to our testing environment."}),"\n",(0,i.jsx)(n.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,i.jsx)(n.p,{children:"The first thing we want to do  is set up a kratix environment, to get started quickly we'll be deploying Kratix on Kind clusters via some helper scripts in the Kratix repo. If you're playing along, clone the Kratix repository and run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"make quick-start\nmake prepare-platform-as-destination\n"})}),"\n",(0,i.jsx)(n.h2,{id:"debugging-scheduling-in-kratix",children:"Debugging Scheduling in Kratix"}),"\n",(0,i.jsx)(n.p,{children:"If you're playing along, you can clone the Runtime Promise by running:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"git clone --depth=1 https://github.com/syntasso/kratix-docs.git runtime-promise\ncd runtime-promise\ngit sparse-checkout set assets/runtime-promise --no-cone\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's install the Promise with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f promise.yaml\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The runtime promise allows users to deploy an Application Runtime as a service via a Resource Request where they can edit the ",(0,i.jsx)(n.code,{children:"lifecycle"}),", ",(0,i.jsx)(n.code,{children:"image"}),", ",(0,i.jsx)(n.code,{children:"servicePort"})," and the number of ",(0,i.jsx)(n.code,{children:"replicas"})," in their deployment."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"lifecycle"})," field determines which Destination to schedule the workloads to and this maps to the label ",(0,i.jsx)(n.code,{children:"environment=${lifecycle}"})," on the Destinations. Whilst working on the Promise, we want to deploy it to a ",(0,i.jsx)(n.code,{children:"testing"})," Destination so the request will look as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: marketplace.kratix.io/v1alpha1\nkind: Runtime\nmetadata:\n  name: example-runtime\n  namespace: default\nspec:\n  lifecycle: testing\n  image: syntasso/website\n  servicePort: 80\n  replicas: 1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Create a file ",(0,i.jsx)(n.code,{children:"example-runtime.yaml"})," with these contents and apply this request with ",(0,i.jsx)(n.code,{children:"kubectl apply -f example-runtime.yaml"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"We can query for the pods created as part of the workflow with selectors that are added to workflow pods by default, this is particularly useful in busy environments with a lot of running pods:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get pods --selector kratix.io/promise-name=runtime,\\\nkratix.io/workflow-type=resource,\\\nkratix.io/workflow-action=configure,\\\nkratix.io/resource-name=example-runtime\n"})}),"\n",(0,i.jsx)(n.p,{children:"The output should look something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME                                                  READY   STATUS      RESTARTS   AGE\nkratix-runtime-example-runtime-instance-24bcb-ffh7w   0/1     Completed   0          20m\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As the workflow has finished running, we can check to ensure the documents were scheduled to the ",(0,i.jsx)(n.code,{children:"testing"})," Destination. Like workflow pods, Works are created with a set of default labels to make querying for Works associated with given Promises and Resource Requests easier. Run the following to get the Work associated with the ",(0,i.jsx)(n.code,{children:"example-runtime"})," resource:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get work --selector kratix.io/resource-name=example-runtime -o yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"The status of the Work shows that it has not been scheduled:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Status:\n  Conditions:\n  - lastTransitionTime: "2025-03-06T07:00:45Z"\n    message: \'No Destinations available work WorkloadGroups: [ae2b1fca515949e5d54fb22b8ed95575]\'\n    reason: UnscheduledWorkloadGroups\n    status: "False"\n    type: Scheduled\n  - lastTransitionTime: "2025-03-06T07:00:45Z"\n    message: WorkGroups that have been scheduled are at the correct Destination(s)\n    reason: ScheduledToCorrectDestinations\n    status: "False"\n    type: Misscheduled\n'})}),"\n",(0,i.jsxs)(n.p,{children:["What does this mean? Essentially, there were no Destinations matching the label ",(0,i.jsx)(n.code,{children:"environment=testing"})," in our environment. Lets review the available Destinations and their labels with:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kubectl get destinations --show-labels\n"})}),"\n",(0,i.jsx)(n.p,{children:"This produces:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME       READY   LABELS\nplatform   True    environment=platform\nworker-1   True    environment=dev\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There ",(0,i.jsx)(n.em,{children:"is"})," no destination with the ",(0,i.jsx)(n.code,{children:"environment=testing"})," label and as a result, the documents could not be scheduled. Lets create the ",(0,i.jsx)(n.code,{children:"testing"})," Destination. To do this we will:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Create a new Cluster"}),"\n",(0,i.jsx)(n.li,{children:"Create a backing State Store for the cluster"}),"\n",(0,i.jsx)(n.li,{children:"Create a new Destination"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"As we are running on kind, we can can create a new cluster by running:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'kind create cluster --image kindest/node:v1.31.2 --name worker-2\nexport WORKER_2="kind-worker-2"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Next, we need to ensure GitOps tooling is available on the new cluster. This can be quickly aided by the Kratix repo again, from the root of the repo, run the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"./scripts/install-gitops --context ${WORKER_2} --path worker-2\n"})}),"\n",(0,i.jsx)(n.p,{children:"Our quick start has configured minio on the cluster so we can use the minio endpoint within the BucketStateStore. Run the following to create the BucketStateStore:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"cat <<EOF > testing-bucket.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: BucketStateStore\nmetadata:\n  name: testing\nspec:\n  authMethod: accessKey\n  bucketName: kratix\n  endpoint: minio.kratix-platform-system.svc.cluster.local\n  insecure: true\n  secretRef:\n    name: minio\n    namespace: default\nstatus: {}\nEOF\n\nkubectl apply -f testing-bucket.yaml --context kind-platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we can create the Destination that is backed by this State Store:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"cat <<EOF > testing-destination.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: Destination\nmetadata:\n  labels:\n    environment: testing\n  name: testing\nspec:\n  cleanup: none\n  filepath:\n    mode: nestedByMetadata\n  stateStoreRef:\n    kind: BucketStateStore\n    name: testing\nstatus: {}\nEOF\n\nkubectl apply -f testing-destination.yaml --context kind-platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"After applying both of these we should set that we have a new running BucketStateStore and Destination. However, when running the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get destinations.platform.kratix.io testing --context kind-platform\n"})}),"\n",(0,i.jsxs)(n.p,{children:["we observe that the ",(0,i.jsx)(n.code,{children:"testing"})," Destination is not Ready"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME      READY\ntesting   False\n"})}),"\n",(0,i.jsx)(n.p,{children:"Similarly, when querying the BucketStateStore with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get BucketStateStore testing --context kind-platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"we can also see that the State Store is not Ready:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME      READY\ntesting   False\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Why is this the case? Lets ",(0,i.jsx)(n.code,{children:"kubectl describe"})," the ",(0,i.jsx)(n.code,{children:"testing"})," Destination. Run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl describe destination testing --context kind-platform\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"status"})," of the Destination includes some conditions which detail why it is not yet ready:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"Status:\n  Conditions:\n    Last Transition Time:  2025-03-05T11:56:05Z\n    Message:               Unable to write test documents to State Store\n    Reason:                StateStoreWriteFailed\n    Status:                False\n    Type:                  Ready\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is reiterated by an event that was fired:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'Events:\n  Type     Reason               Age   From                   Message\n  ----     ------               ----  ----                   -------\n  Warning  DestinationNotReady  20m   DestinationController  Failed to write test documents to Destination "testing": secret "minio" not found in namespace "default"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When creating both Destinations and State Stores, Kratix checks to see that the defined locations can be written to with the provided credentials before marking them as ",(0,i.jsx)(n.code,{children:"Ready"}),". We see a similar ",(0,i.jsx)(n.code,{children:"status"})," and ",(0,i.jsx)(n.code,{children:"event"})," fired for the ",(0,i.jsx)(n.code,{children:"testing"})," BucketStateStore:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'Status:\n  Conditions:\n    Last Transition Time:  2025-03-05T11:30:07Z\n    Message:               Error initialising writer: secret "minio" not found in namespace "default"\n    Reason:                ErrorInitialisingWriter\n    Status:                False\n    Type:                  Ready\n  Status:                  NotReady\nEvents:\n  Type     Reason    Age   From                        Message\n  ----     ------    ----  ----                        -------\n  Warning  NotReady  52m   BucketStateStoreController  BucketStateStore "testing" is not ready: Error initialising writer: secret "minio" not found in namespace "default"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This means that no work can be scheduled to these destinations until the problems are remedied, so lets fix the issue. Our minio credential isn't quite right, we need to edit the ",(0,i.jsx)(n.code,{children:"testing"})," BucketStateStore to update the name of the secretRef from ",(0,i.jsx)(n.code,{children:"minio"})," to ",(0,i.jsx)(n.code,{children:"minio-credentials"}),". Update the BucketStateStore and in just a few moments, both the State Store and Destination will become ",(0,i.jsx)(n.code,{children:"Ready"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'Status:\n  Conditions:\n    Last Transition Time:  2025-03-05T12:28:31Z\n    Message:               State store is ready\n    Reason:                StateStoreReady\n    Status:                True\n    Type:                  Ready\n  Status:                  Ready\nEvents:\n  Type     Reason    Age   From                        Message\n  ----     ------    ----  ----                        -------\n  Warning  NotReady  59m   BucketStateStoreController  BucketStateStore "testing" is not ready: Error initialising writer: secret "minio" not found in namespace "default"\n  Normal   Ready     65s   BucketStateStoreController  BucketStateStore "testing" is ready\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'Status:\n  Conditions:\n    Last Transition Time:  2025-03-05T12:28:31Z\n    Message:               Test documents written to State Store\n    Reason:                TestDocumentsWritten\n    Status:                True\n    Type:                  Ready\nEvents:\n  Type     Reason               Age   From                   Message\n  ----     ------               ----  ----                   -------\n  Warning  DestinationNotReady  34m   DestinationController  Failed to write test documents to Destination "testing": secret "minio" not found in namespace "default"\n  Normal   Ready                114s  DestinationController  Destination "testing" is ready\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now that the Destination is up and Healthy, we can see that the work has been scheduled successfully:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'status:\n  conditions:\n  - lastTransitionTime: "2025-03-06T07:08:03Z"\n    message: All WorkloadGroups scheduled to Destination(s)\n    reason: ScheduledToDestinations\n    status: "True"\n    type: Scheduled\n'})}),"\n",(0,i.jsxs)(n.p,{children:["And, more importantly, our ",(0,i.jsx)(n.code,{children:"example-runtime"})," app is up and running. We can visit it at ",(0,i.jsx)(n.a,{href:"http://example-runtime.default.local.gd:31338",children:"http://example-runtime.default.local.gd:31338"})]}),"\n","\n",(0,i.jsxs)("figure",{className:"diagram",children:[(0,i.jsx)("img",{className:"large",src:r,alt:"An image of the running Runtime App in the browser"}),(0,i.jsx)("figcaption",{children:"Runtime App"})]}),"\n",(0,i.jsx)(n.p,{children:"Now that it's deployed successfully, we're ready to build on the Runtime Promise and add the security scan as a new step when configuring resource requests."}),"\n",(0,i.jsxs)(n.p,{children:["We can bootstrap this step with the ",(0,i.jsx)(n.a,{href:"/main/kratix-cli/intro",children:"Kratix CLI's"})," ",(0,i.jsx)(n.code,{children:"add container"})," command. From the root of the Runtime Promise directory, you can run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kratix add container resource/configure/instance \\\n  --image ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0 \\\n  --name security-scan\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This command adds a new container to the existing resource configure workflow with the name ",(0,i.jsx)(n.code,{children:"security-scan"})," and the image ",(0,i.jsx)(n.code,{children:"ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Your directory structure should now look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"\u251c\u2500\u2500 example-resource.yaml\n\u251c\u2500\u2500 promise.yaml\n\u2514\u2500\u2500 workflows\n    \u2514\u2500\u2500 resource\n        \u2514\u2500\u2500 configure\n            \u2514\u2500\u2500 instance\n                \u251c\u2500\u2500 deploy-resources\n                \u2502\xa0\xa0 \u251c\u2500\u2500 Dockerfile\n                \u2502\xa0\xa0 \u251c\u2500\u2500 resources\n                \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 postgres-request-template.yaml\n                \u2502\xa0\xa0 \u2502\xa0\xa0 \u251c\u2500\u2500 redis-request-template.yaml\n                \u2502\xa0\xa0 \u2502\xa0\xa0 \u2514\u2500\u2500 runtime-request-template.yaml\n                \u2502\xa0\xa0 \u2514\u2500\u2500 scripts\n                \u2502\xa0\xa0     \u2514\u2500\u2500 pipeline.rb\n                \u2514\u2500\u2500 security-scan\n                    \u251c\u2500\u2500 Dockerfile\n                    \u251c\u2500\u2500 resources\n                    \u2514\u2500\u2500 scripts\n                        \u2514\u2500\u2500 pipeline.sh\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You'll also see an addition to the ",(0,i.jsx)(n.code,{children:"promise.yaml"}),", appending the ",(0,i.jsx)(n.code,{children:"security-scan"})," container to the list of containers in the ",(0,i.jsx)(n.code,{children:"resource-configure"})," Pipeline"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: resource-configure\n          spec:\n            containers:\n              - resource-configure\n              image: ghcr.io/syntasso/kratix-docs/runtime-configure-pipeline:v0.1.0\n              name: resource-configure\n  #highlight-start\n              - image: ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0\n                name: security-scan\n  #highlight-end\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Next, we need to bring this image into existence. Update the new ",(0,i.jsx)(n.code,{children:"pipeline.sh"})," file in the ",(0,i.jsx)(n.code,{children:"security-scan"})," directory to look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/usr/bin/env sh\n\nset -euxo pipefail\n\nimage="$(yq eval \'.spec.image\' /kratix/input/object.yaml)"\n\necho "Scanning ${image}"\n\nif [ $DEBUG = "true" ]; then\n  DEBUG_MODE=true\n  echo "Running in debug mode"\nelse \n  DEBUG_MODE=false\nfi\n\nTRIVY_DEBUG=$DEBUG_MODE trivy image --format=json --output=results.json "${image}" > results.json\n\nhealth_state="healthy"\n\nif [ "$(jq \'.[] | select(.Vulnerabilities != null) | length\' results.json)" != "" ]; then\n  health_state="degraded"\nfi\n\nresource_name=$(yq \'.metadata.name\' /kratix/input/object.yaml)\nnamespace="default"\n\nmkdir -p /kratix/output/platform/\n\ncat <<EOF > /kratix/output/platform/health-record.yaml\napiVersion: platform.kratix.io/v1alpha1\nkind: HealthRecord\nmetadata:\n  name: rubyapp-${resource_name}\n  namespace: ${namespace}\ndata:\n  promiseRef:\n    name: rubyapp\n  resourceRef:\n    name: ${resource_name}\n    namespace: ${namespace}\n  state: ${health_state}\n  lastRun: $(date +%s)\n  details:\n    results: ""\nEOF\n\ncat results.json | yq -P > results.yaml\nyq e -i \'.data.details.results = load("results.yaml")\' /kratix/output/platform/health-record.yaml\n\ncat <<EOF > /kratix/metadata/destination-selectors.yaml\n- directory: platform\n  matchLabels:\n    environment: platform\nEOF\n'})}),"\n",(0,i.jsxs)(n.p,{children:["This script retrieves the ",(0,i.jsx)(n.code,{children:"image"})," specified in the request, scans it with ",(0,i.jsx)(n.code,{children:"trivy"})," and outputs a ",(0,i.jsx)(n.code,{children:"HealthRecord"})," detailing the results."]}),"\n",(0,i.jsx)(n.p,{children:"To use Trivy, we also need to update the generated Dockerfile to install the Trivy CLI. Update your Dockerfile to look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dockerfile",children:'FROM "alpine"\n\nRUN apk update && apk add --no-cache yq curl jq\n\nRUN curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v0.18.3\n\nADD scripts/pipeline.sh /usr/bin/pipeline.sh\nADD resources resources\n\nRUN chmod +x /usr/bin/pipeline.sh\n\nCMD [ "sh", "-c", "pipeline.sh" ]\nENTRYPOINT []\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To ensure the new security-scan image is are available on the kind clusters, we need to build it and load it onto the kind node. Run the following from the ",(0,i.jsx)(n.code,{children:"runtime-promise/workflows/resource/configure/instance/security-scan"})," directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"docker build . --tag ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0\nkind load docker-image ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0 --name platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"Whilst testing this command, we'll run in debug mode should any issues come up. Our script has already been configured to allow this to be set via an environment variable."}),"\n",(0,i.jsx)(n.p,{children:"Add the following lines to the Promise spec for the newly introduced container:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- image: ghcr.io/syntasso/kratix-docs/trivy-scan:v1.0.0\n  name: security-scan\n  #highlight-start\n  envs:\n  - name: DEBUG\n    value: "true"\n  #highlight-end\n'})}),"\n",(0,i.jsx)(n.p,{children:"We're nearly ready to install the Promise!"}),"\n",(0,i.jsx)(n.h2,{id:"identifying-invalid-workflows",children:"Identifying invalid workflows"}),"\n",(0,i.jsx)(n.p,{children:"Before you can install your Promise, Kratix ensures that your Promise has valid Workflows definitions that can be used to generate your workflow pods. Apply your updated promise with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply -f promise.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should see a message that includes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'json: unknown field "envs"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["We have a slight typo in the Promise spec for the new workflow, ",(0,i.jsx)(n.code,{children:"envs"})," should be ",(0,i.jsx)(n.code,{children:"env"}),". Correct this and apply the promise again."]}),"\n",(0,i.jsxs)(n.p,{children:["Re-applying the Promise will trigger the Workflows for the ",(0,i.jsx)(n.code,{children:"example-runtime"})," request which should now generate a HealthRecord with the security scan results. Run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kubectl get healthrecord --context kind-platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"and you should see output similar to:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"NAME                      STATUS    AGE\nruntime-example-runtime   degraded  8m12s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Also, as the healthrecord reference the ",(0,i.jsx)(n.code,{children:"example-runtime"})," request, the request should be updated to reflect the results in the HealthRecord. Run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"kubectl describe runtime example-runtime --context kind-platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"And the should see something similar to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  Health Record:\n    Details:\n      Results:\n        ...\n    Last Run:                               1741248436\n    State:                                  degraded\n"})}),"\n",(0,i.jsx)(n.p,{children:"Great! The updated Runtime Promise is now running a provisioning requests that"}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"We've explored some of the common stumbling blocks that can come up when working wih Kratix - issues with scheduling, configuring Destinations - and the features of Kratix you can use to as debugging tools."}),"\n",(0,i.jsxs)(n.p,{children:["Many of these are new features we've introduced following feedback from our customers so if there is a gotcha that has caught you out in the past, let us know via ",(0,i.jsx)(n.a,{href:"https://github.com/syntasso/kratix",children:"Github"})," or our ",(0,i.jsx)(n.a,{href:"https://kratixworkspace.slack.com/",children:"Community Slack"})," - we're alway happy to hear from users."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}},70929:e=>{e.exports=JSON.parse('{"permalink":"/blog/debugging-promise-updates","source":"@site/blog/2025-03-05-debugging/index.mdx","title":"Debugging in Kratix","description":"Identifying the tools you can use to debug your Promise rollouts","date":"2025-03-05T00:00:00.000Z","tags":[{"inline":true,"label":"kratix","permalink":"/blog/tags/kratix"},{"inline":true,"label":"kratix internals","permalink":"/blog/tags/kratix-internals"},{"inline":true,"label":"debugging","permalink":"/blog/tags/debugging"}],"readingTime":11.15,"hasTruncateMarker":true,"authors":[{"name":"Sapphire Mason-Brown","title":"Engineer @ Syntasso","url":"https://github.com/saphmb","imageURL":"https://github.com/saphmb.png","key":"sapphire","page":null}],"frontMatter":{"slug":"debugging-promise-updates","title":"Debugging in Kratix","description":"Identifying the tools you can use to debug your Promise rollouts","authors":["sapphire"],"tags":["kratix","kratix internals","debugging"]},"unlisted":false,"prevItem":{"title":"Kratix, Backstage, and OIDC","permalink":"/blog/backstage-and-keycloak"},"nextItem":{"title":"How to write Compound Promises","permalink":"/blog/compound-promises"}}')}}]);