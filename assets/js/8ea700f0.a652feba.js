"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[1616],{4367:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"main/reference/destinations/intro","title":"Destination","description":"Documentation for the Kratix Destination Custom Resource","source":"@site/docs/main/03-reference/13-destinations/01-destinations.md","sourceDirName":"main/03-reference/13-destinations","slug":"/main/reference/destinations/intro","permalink":"/main/reference/destinations/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/03-reference/13-destinations/01-destinations.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"description":"Documentation for the Kratix Destination Custom Resource","title":"Destination","sidebar_label":"Destinations","id":"intro"},"sidebar":"mainSidebar","previous":{"title":"Workflows","permalink":"/main/reference/workflows"},"next":{"title":"Managing Multiple Destinations","permalink":"/main/reference/destinations/multidestination-management"}}');var s=n(4848),o=n(8453);const a={description:"Documentation for the Kratix Destination Custom Resource",title:"Destination",sidebar_label:"Destinations",id:"intro"},r=void 0,d={},l=[{value:"Status",id:"status",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The Kratix Destination Custom Resource Definition (CRD) is the representation of\na system that Kratix can write documents to. These documents are then\nreconciled by an external tool."}),"\n",(0,s.jsx)(t.p,{children:"Some example use cases:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://kubernetes.io/",children:"Kubernetes cluster"}),": Kratix will scheduled documents (Kubernetes manifests) to\nthe Destination, and then a GitOps tool running on the Kubernetes cluster,\nsuch as Flux or ArgoCD with pull down the documents and deploy them. See our\n",(0,s.jsx)(t.a,{href:"/category/installing-gitops-agent",children:"GitOps Agent documentation"})," for more information."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://www.terraform.io/",children:"Terraform"}),": There are many toolings that exist to trigger a ",(0,s.jsx)(t.code,{children:"teraform apply"}),"\nwhen a new Terraform file is committed to a Git repository. For example\n",(0,s.jsx)(t.a,{href:"https://www.hashicorp.com/resources/gitops-and-terraform-enterprise-a-match-made-in-heaven-at-state-farm",children:"Terraform\nEnterprise"}),"\nhas built in support for GitOps workflows."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://www.ansible.com/",children:"Ansible"}),", where an Ansible Tower can be configured to reconcile from a Git\nrepository."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://backstage.io/",children:"Backstage"}),", where a Backstage instance can be configured have its ",(0,s.jsx)(t.a,{href:"https://backstage.io/docs/integrations/github/discovery",children:"Catalog\nfilled from a Git\nrepository"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Below is the full Spec for the Destination CRD:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Destination\nmetadata:\n  # The Destination name is an arbitrary name that represent where workloads will be scheduled by the platform\n  name: destination-name\n  # The Destination labels are arbitrary key/value pairs that can be used for scheduling\n  #   the installation of Promises and the Resources\n  labels:\n    environment: dev\nspec:\n  # Path within the State Store to write to.\n  # Optional, defaults to the name of the Destination.\n  # To write straight to the root of the State Store, set it to `/`.\n  path: path/in/statestore\n\n  # Optional, defaults to false.\n  # By default, Kratix will schedule workloads for Promises without\n  #   `destinationSelectors` to all available Destinations.\n  # If this property is set to true, Kratix will only schedule Workloads\n  #   to this Destination if the Promise `destinationSelectors` match\n  #   this Destination's labels\n  strictMatchLabels: false\n\n  # Optional, defaults to `nestedByMetadata`\n  # The mode to use when writing to the State Store, valid options are:\n  #   - nestedByMetadata: Writes to the State Store in a nested structure\n  #   - none: Writes to the State Store in a flat structure\n  filepath:\n    mode: nestedByMetadata | none\n\n  # Optional, defaults to `none`\n  # The cleanup policy to use when deleting the Destination, valid options are:\n  #   - none: No cleanup will be performed\n  #   - all: All files in the State Store for this Destination will be deleted\n  #          when the Destination is deleted\n  cleanup: none\n\n  # Required\n  stateStoreRef:\n    # The name of the State Store to use: required\n    name: default\n    # The kind of the State Store to use: required, valid options: GitStateStore, BucketStateStore\n    kind: BucketStateStore\n"})}),"\n",(0,s.jsxs)(t.p,{children:["When a new Destination is created in the platform cluster, Kratix will write to\ntwo paths in the ",(0,s.jsx)(t.a,{href:"../statestore/intro",children:"State Store"}),": one for ",(0,s.jsx)(t.code,{children:"resources"}),", one\nfor ",(0,s.jsx)(t.code,{children:"dependencies"}),". The path within the ",(0,s.jsx)(t.code,{children:"State Store"})," follows the pattern:"]}),"\n",(0,s.jsxs)(t.p,{children:["For ",(0,s.jsx)(t.code,{children:"dependencies"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"statestore.Spec.Path/\n    destination.Spec.Path/\n        dependencies/\n            promise.Name/\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For ",(0,s.jsx)(t.code,{children:"resources"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"statestore.Spec.Path/\n    destination.Spec.Path/\n        resources/\n            resource.Namespace/\n                promise.Name/\n                    resource.Namespace/\n"})}),"\n",(0,s.jsx)(t.p,{children:"For example, for the following configuration:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"---\napiVersion: platform.kratix.io/v1alpha1\nkind: BucketStateStore\nmetadata:\n  name: default\n  namespace: default\nspec:\n  path: destinations\n  endpoint: s3.amazonaws.com\n  insecure: true\n  bucketName: kratix\n  secretRef:\n    name: aws-credentials\n---\napiVersion: platform.kratix.io/v1alpha1\nkind: Destination\nmetadata:\n  name: worker-1\n  labels:\n    environment: dev\nspec:\n  path: dev\n  stateStoreRef:\n    name: default\n    kind: BucketStateStore\n"})}),"\n",(0,s.jsx)(t.p,{children:"The following directories would be created in the State Store:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"destinations/dev/default/dependencies/"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"destinations/dev/default/resources/"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Kratix will, by default, write to unique directories within those paths depending on the\nPromise or Resource being requested. You can stop this behaviour by setting the ",(0,s.jsx)(t.code,{children:"filepath.mode"})," to ",(0,s.jsx)(t.code,{children:"none"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["Pre-requisites, like CRDs, are written to the ",(0,s.jsx)(t.code,{children:"dependencies"})," subdirectory. This setup is\noften required by GitOps tools to ensure that all dependencies are ready before the\nresources themselves are applied."]})}),"\n",(0,s.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,s.jsxs)(t.p,{children:["A condition of type ",(0,s.jsx)(t.code,{children:"Ready"})," is provided to enable waiting for the Destination to be ready. The Destination is considered\nready when Kratix is able to write test documents successfully."]}),"\n",(0,s.jsxs)(t.p,{children:["See the example below showing a Destination with ",(0,s.jsx)(t.code,{children:"Ready"})," condition."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"$ kubectl describe destinations.platform.kratix.io worker-1\nName:         worker-1\n...\nStatus:\n  Conditions:\n    Last Transition Time:  2025-03-04T15:26:21Z\n    Message:               Test documents written to State Store\n    Reason:                TestDocumentsWritten\n    Status:                True\n    Type:                  Ready\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["The test documents include ",(0,s.jsx)(t.code,{children:"dependencies/kratix-canary-namespace.yaml"})," and ",(0,s.jsx)(t.code,{children:"resources/kratix-canary-configmap.yaml"}),". When\nthe ",(0,s.jsx)(t.code,{children:"Ready"})," condition status is ",(0,s.jsx)(t.code,{children:"True"})," and the target is a Kubernetes cluster set up to reconcile on the Destination, you\nwill see a ",(0,s.jsx)(t.code,{children:"kratix-worker-system"})," namespace and a ",(0,s.jsx)(t.code,{children:"kratix-info"})," configmap on the target cluster."]})})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(6540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);