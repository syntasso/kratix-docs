"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[1806],{322:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var i=n(9310),a=n(4848),s=n(8453);const o=n.p+"assets/images/figure01-5541dd5da0b16b7636da75926e813b01.jpg",l={slug:"local-dev-pipelines",title:"Speeding up local dev: fast feedback when building pipelines",description:"Learn how to speed up local development with fast feedback loops when building pipelines.",authors:["aslan","derik"],tags:["kratix","promises","pipelines"]},r=void 0,c={authorsImageUrls:[void 0,void 0]},p=[{value:"Testing your Pipeline stages",id:"testing-your-pipeline-stages",level:2},{value:"Running the pipeline stage locally",id:"running-the-pipeline-stage-locally",level:3},{value:"Running automated tests",id:"running-automated-tests",level:3},{value:"Testing imperative actions",id:"testing-imperative-actions",level:3},{value:"Running the Stage as a Container",id:"running-the-stage-as-a-container",level:3},{value:"Testing the Promise",id:"testing-the-promise",level:2},{value:"Populating the image cache",id:"populating-the-image-cache",level:3},{value:"Setting image pull policy",id:"setting-image-pull-policy",level:3},{value:"Automating e2e tests",id:"automating-e2e-tests",level:3},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Are you building Pipelines and unsure about the best way to test and iterate over them? Worry not. Your questions are about to be answered!"}),"\n",(0,a.jsx)(t.p,{children:"In this blog post, you will gain insights into how you can get faster feedback on your Pipeline development by:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Running the pipeline stage locally"}),"\n",(0,a.jsx)(t.li,{children:"Running automated tests"}),"\n",(0,a.jsx)(t.li,{children:"Testing imperative actions"}),"\n",(0,a.jsx)(t.li,{children:"Running the stage as a container"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We will also look into how to more effectively run system-level tests by"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Populating the image cache"}),"\n",(0,a.jsx)(t.li,{children:"Setting the image pull policy"}),"\n",(0,a.jsx)(t.li,{children:"Automating end-to-end (e2e) tests"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'Click "read more" below to continue!'}),"\n","\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h2,{id:"testing-your-pipeline-stages",children:"Testing your Pipeline stages"}),"\n",(0,a.jsx)(t.p,{children:"As you may know, a Promise includes a set of workflows that are executed as part of a request for that Promise. The workflow itself is a series of Pipelines, and each Pipeline contains multiple Stages. These stages are usually encapsulated in a Container image."}),"\n",(0,a.jsxs)(t.p,{children:["At the start of a Pipeline Stage, Kratix will provide, in the ",(0,a.jsx)(t.code,{children:"/kratix/input"})," directory, a YAML file (",(0,a.jsx)(t.code,{children:"object.yaml"}),") representing the user's resource request. This file is the same object that the user has applied to the Platform cluster."]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["We will only cover building and testing a Resource Request Pipeline stage in this post. A Promise Pipeline Stage has slightly different inputs, but the process to build and test is the same. Check the ",(0,a.jsx)(t.a,{href:"/main/reference/workflows",children:"Workflow Reference docs"})," for more details."]})}),"\n",(0,a.jsxs)(t.p,{children:["Kratix expects the Stage to produce outputs, and those outputs are stored in either ",(0,a.jsx)(t.code,{children:"/kratix/output"})," or ",(0,a.jsx)(t.code,{children:"/kratix/metadata"})," (depending on the purpose; not clear? Read the ",(0,a.jsx)(t.a,{href:"/main/reference/workflows#volumes",children:"Workflows reference docs"}),")."]}),"\n",(0,a.jsx)(t.p,{children:"One of the main benefits of Kratix is the ability to test these Stages. In this blog post, let's assume we are building the following Pipeline stage:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["It takes as input an object containing ",(0,a.jsx)(t.code,{children:"spec.contents"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["It produces a ConfigMap with the ",(0,a.jsx)(t.code,{children:"spec.contents"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In Python, this stage may look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'#!/usr/bin/env python3\nimport yaml, sys\n\nwith open("/kratix/input/object.yaml") as f:\n    obj = yaml.safe_load(f)\n\nname = obj.get("metadata", {}).get("name", "example-config")\ncontents = obj.get("spec", {}).get("contents", {})\n\nconfigmap = {\n    "apiVersion": "v1",\n    "kind": "ConfigMap",\n    "metadata": {"name": name, "namespace": "default"},\n    "data": contents\n}\n\nwith open("/kratix/output/configmap.yaml", "w") as out:\n    yaml.dump(configmap, out)\n'})}),"\n",(0,a.jsx)(t.p,{children:"Pipeline Stages can be tested at different levels. In the next sections, we will explore ways you could implement and test at different levels, from unit to end-to-end tests. The diagram below illustrate some of the testing strategies you could use."}),"\n","\n",(0,a.jsxs)("figure",{className:"diagram",children:[(0,a.jsx)("img",{className:"large",src:o,alt:"A diagram showing the different stages a pipeline stage can be tested"}),(0,a.jsx)("figcaption",{children:"Testing strategies for a pipeline stage"})]}),"\n",(0,a.jsx)(t.h3,{id:"running-the-pipeline-stage-locally",children:"Running the pipeline stage locally"}),"\n",(0,a.jsx)(t.p,{children:"The simplest place to start is to make it runnable locally. That means you will be able to execute the script and quickly verify its output."}),"\n",(0,a.jsx)(t.p,{children:"If we try to execute our Python script above, it will fail. It's relying on the Kratix Volumes, which (most likely) are not available on your machine."}),"\n",(0,a.jsx)(t.p,{children:"A simple strategy is to parameterise the inputs and outputs. For example, you could update the script to read the volumes from environment variables, defaulting to the Kratix volumes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",metastring:',title="generate_configmap.py"',children:'#!/usr/bin/env python3\nimport yaml, sys, os\n\n# highlight-start\ninput_path = os.getenv("INPUT_PATH") or "/kratix/input/object.yaml"\noutput_path = os.getenv("OUTPUT_PATH") or "/kratix/output/configmap.yaml"\n\nwith open(input_path) as f:\n    obj = yaml.safe_load(f)\n# highlight-end\n\nname = obj.get("metadata", {}).get("name", "example-config")\ncontents = obj.get("spec", {}).get("contents", {})\n\nconfigmap = {\n    "apiVersion": "v1",\n    "kind": "ConfigMap",\n    "metadata": {"name": name, "namespace": "default"},\n    "data": contents\n}\n\n# highlight-start\nwith open(output_path, "w") as out:\n    yaml.dump(configmap, out)\n# highlight-end\n'})}),"\n",(0,a.jsx)(t.p,{children:"With this simple change, you can now run the script locally, passing the input and output as environment variables. First, create an example input file:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"mkdir {input,output}\ncat <<EOF > input/object.yaml\nmetadata:\n  name: configtest\nspec:\n  contents:\n    keyOne: one\n    keyTwo: two\nEOF\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Next, save the Python script in a file (call it ",(0,a.jsx)(t.code,{children:"generate_configmap.py"}),") and make it executable. Then, set the environment variables and execute the script:"]}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsxs)(t.p,{children:["You may need to install ",(0,a.jsx)(t.code,{children:"pyyaml"})," to execute the script below."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"pip3 install pyyaml\n"})})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"INPUT_PATH=input/object.yaml OUTPUT_PATH=output/configmap.yaml ./generate_configmap.py\n"})}),"\n",(0,a.jsxs)(t.p,{children:["This should produce an ",(0,a.jsx)(t.code,{children:"output-example.yaml"})," locally that matches your expectations:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"$ cat output-example.yaml\napiVersion: v1\ndata:\n  keyOne: one\n  keyTwo: two\nkind: ConfigMap\nmetadata:\n  name: configtest\n  namespace: default\n"})}),"\n",(0,a.jsx)(t.p,{children:"This is a start, but we can do better."}),"\n",(0,a.jsx)(t.h3,{id:"running-automated-tests",children:"Running automated tests"}),"\n",(0,a.jsx)(t.p,{children:"Running locally is great, but it doesn't allow us to quickly verify if our script is working. If you look closely, you'll notice that a stage is not that different from a normal function in most programming languages: it transforms inputs into outputs."}),"\n",(0,a.jsx)(t.p,{children:"Therefore, it should be quite simple to unit test these using whatever libraries your language of choice provides. Let's do that with our script."}),"\n",(0,a.jsx)(t.p,{children:"First, let's refactor it to make it more testable by extracting the main logic into a function:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",metastring:',title="generate_configmap.py"',children:'#!/usr/bin/env python3\nimport yaml, sys, os\n\ndef generate_configmap(input_path=None, output_path=None):\n    input_path = input_path or os.getenv("INPUT_PATH") or "/kratix/input/object.yaml"\n    output_path = output_path or os.getenv("OUTPUT_PATH") or "/kratix/output/configmap.yaml"\n\n    with open(input_path) as f:\n        obj = yaml.safe_load(f)\n\n    name = obj.get("metadata", {}).get("name", "example-config")\n    contents = obj.get("spec", {}).get("contents", {})\n\n    configmap = {\n        "apiVersion": "v1",\n        "kind": "ConfigMap",\n        "metadata": {"name": name, "namespace": "default"},\n        "data": contents\n    }\n\n    with open(output_path, "w") as out:\n        yaml.dump(configmap, out)\n\nif __name__ == "__main__":\n    generate_configmap()\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Next, let's create a basic unit test file (called ",(0,a.jsx)(t.code,{children:"test_generate_configmap.py"}),") for it:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",metastring:',title="test_generate_configmap.py"',children:'#!/usr/bin/env python3\nimport unittest\nimport yaml\nimport tempfile\nimport os\nfrom generate_configmap import generate_configmap\n\nclass TestGenerateConfigMap(unittest.TestCase):\n    def test_configmap_generation(self):\n        input_data = {\n            "metadata": {"name": "test-config"},\n            "spec": {"contents": {"foo": "bar", "baz": "qux"}}\n        }\n\n        with tempfile.NamedTemporaryFile(mode="w+", delete=False) as tmp_in:\n            yaml.dump(input_data, tmp_in)\n            tmp_in_path = tmp_in.name\n\n        with tempfile.NamedTemporaryFile(mode="r", delete=False) as tmp_out:\n            tmp_out_path = tmp_out.name\n\n        try:\n            generate_configmap(input_path=tmp_in_path, output_path=tmp_out_path)\n\n            with open(tmp_out_path) as f:\n                configmap = yaml.safe_load(f)\n\n            self.assertEqual(configmap["kind"], "ConfigMap")\n            self.assertEqual(configmap["metadata"]["name"], "test-config")\n            self.assertEqual(configmap["data"], {"foo": "bar", "baz": "qux"})\n\n        finally:\n            os.remove(tmp_in_path)\n            os.remove(tmp_out_path)\n\nif __name__ == "__main__":\n    unittest.main()\n'})}),"\n",(0,a.jsx)(t.p,{children:"You should now be able to run the tests:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"$ python3 test_generate_configmap.py\n.\n----------------------------------------------------------------------\nRan 1 test in 0.005s\n\nOK\n"})}),"\n",(0,a.jsx)(t.p,{children:"As you can see, this is a very simple use case and test. However, your pipeline stage may be complex, with several branches in the code. Adding a unit test suite like the above can help you move faster by ensuring you're not accidentally breaking existing features."}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:["It's very common for Promise Writers to start with ",(0,a.jsx)(t.code,{children:"bash"})," for their pipeline stages. While here at Syntasso we are #TeamBash, stages will often evolve into their own beasts, together with the scripts that back them. Consider the language you choose for your stages carefully, as some make it much harder to test than others \ud83d\ude09."]})}),"\n",(0,a.jsx)(t.h3,{id:"testing-imperative-actions",children:"Testing imperative actions"}),"\n",(0,a.jsxs)(t.p,{children:["A common use case is for the Stage to execute imperative actions, like calling APIs to validate or create external resources. At the unit level, you could easily add tests for those cases by using whatever features/libraries your language provides for mocking those external calls. For example, in Python, you could use the built-in ",(0,a.jsx)(t.a,{href:"https://docs.python.org/3/library/unittest.mock.html",children:"unittest.mock"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The takeaway is that your stage is ",(0,a.jsx)(t.em,{children:"just software"}),". You can use the same tools and methodologies that you use to build other pieces of software to build the stages. Over time, you will build a suite of unit, integration, and system tests around your stages to guarantee their functionality."]}),"\n",(0,a.jsx)(t.h3,{id:"running-the-stage-as-a-container",children:"Running the Stage as a Container"}),"\n",(0,a.jsx)(t.p,{children:"Once you have your test suite running locally, you may want to execute a test in your container engine to guarantee it works in a containerised environment. In our example, we can run it in Docker by creating the following Dockerfile:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-Dockerfile",children:'FROM python:3.10-slim\n\nWORKDIR /app\n\n# Copy the script into the container\nCOPY generate_configmap.py .\n\n# Install PyYAML\nRUN pip install --no-cache-dir pyyaml\n\n# Run the script\nCMD ["python", "generate_configmap.py"]\n'})}),"\n",(0,a.jsx)(t.p,{children:"We can then build it:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"docker build -t configmap-generator:dev .\n"})}),"\n",(0,a.jsxs)(t.p,{children:["To execute it, you will need to ensure the container has access to the expected Kratix Volumes. You can use the ",(0,a.jsx)(t.code,{children:"--volume"})," flag to mount a local directory into the container at the specified path. To run the container, run:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"docker run --rm \\\n  --volume $(pwd)/input:/kratix/input \\\n  --volume $(pwd)/output:/kratix/output \\\n  configmap-generator:dev\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Executing the command above will mount your local ",(0,a.jsx)(t.code,{children:"input"})," and ",(0,a.jsx)(t.code,{children:"output"})," directories as the Kratix Volumes. You should see the generated output in the ",(0,a.jsx)(t.code,{children:"output"})," directory. You can play around and change the inputs to verify it further."]}),"\n",(0,a.jsx)(t.h2,{id:"testing-the-promise",children:"Testing the Promise"}),"\n",(0,a.jsx)(t.p,{children:"Great! At this point, you are confident that your stage performs as expected, and you're ready to add it to your Promise. In this section, let's explore how to validate your stages in an actual Promise."}),"\n",(0,a.jsx)(t.h3,{id:"populating-the-image-cache",children:"Populating the image cache"}),"\n",(0,a.jsxs)(t.p,{children:["If you just add your stage to the Promise and install it, you will likely get an ",(0,a.jsx)(t.code,{children:"ErrImagePull"})," error. That's because Kubernetes will try to download the image from the actual registry."]}),"\n",(0,a.jsx)(t.p,{children:"You could build and push your image to the registry, apply your Promise, test, and repeat; however, that can be quite error-prone and slow."}),"\n",(0,a.jsx)(t.p,{children:"If you are running Kratix in a local Kubernetes cluster, deployed via KinD or Minikube, for example, a simpler approach is to load the container image directly into the Kubernetes node cache."}),"\n",(0,a.jsx)(t.p,{children:"If using KinD, you can run:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kind load docker-image configmap-generator:dev --name platform\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that we are tagging the image with a ",(0,a.jsx)(t.code,{children:"dev"})," tag. We recommend you set a tag in your container image: when it's not set (or when it's ",(0,a.jsx)(t.code,{children:"latest"}),"), extra configuration is required for Kubernetes to use the correct cached image."]}),"\n",(0,a.jsx)(t.h3,{id:"setting-image-pull-policy",children:"Setting image pull policy"}),"\n",(0,a.jsxs)(t.p,{children:["By default, the Kratix Pipeline Pod containers will have the ",(0,a.jsx)(t.code,{children:"imagePullPolicy"})," set to the defaults that ",(0,a.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting",children:"Kubernetes defines"}),". In development, you often want that to be either ",(0,a.jsx)(t.code,{children:"IfNotPresent"})," or ",(0,a.jsx)(t.code,{children:"Never"}),". That is, Kubernetes should only attempt to download from the registry when it's not already in the cache (or never)."]}),"\n",(0,a.jsx)(t.p,{children:"Image Pull Policy is a Stage-level configuration: you set it per container in your Pipeline, and different stages may have a different pull policy. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: postgresql\nspec:\n  api: # ...\n  workflows:\n    resources:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: instance\n          spec:\n            containers:\n              - name: stageOne\n                image: configmap-generator:dev\n                #highlight-next-line\n                imagePullPolicy: Never\n              - name: stageTwo\n                image: another-stage:v1.0.0\n                #highlight-next-line\n                imagePullPolicy: Always\n"})}),"\n",(0,a.jsx)(t.p,{children:"If you are making changes to your stage but are not actually seeing the results you expect, double-check you are using the image you actually want!"}),"\n",(0,a.jsx)(t.h3,{id:"automating-e2e-tests",children:"Automating e2e tests"}),"\n",(0,a.jsx)(t.p,{children:"You will also want to test the full end-to-end result of executing the Pipeline. While the steps above gave you confidence that each individual stage will work in isolation, you still need the full pipeline execution to validate whether they all, together, produce the expected result."}),"\n",(0,a.jsx)(t.p,{children:"The simplest way to test this is to run something akin to a system test:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Install the Promise:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Verify the expected dependencies are installed in the Destination."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Request a Resource from the Promise:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Verify the expected resources are created in the Destination."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In fact, this is how we test all the Promises in our Marketplace. For example, the ",(0,a.jsx)(t.a,{href:"https://github.com/syntasso/kratix-marketplace/blob/main/redis/internal/scripts/test",children:"Redis Promise"})," executes the following tests on CI:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:'#!/usr/bin/env bash\nset -e\n\ntest_promise() {\n  kubectl wait promise/redis --for=condition=ConfigureWorkflowCompleted --timeout=120s\n  kubectl get crd redisfailovers.databases.spotahome.com\n  kubectl wait --for=condition=Available --timeout=5s deployment/redisoperator\n}\n\ntest_resource_request() {\n  kubectl wait --for=condition=Available --timeout=5s deployment/rfs-example\n}\n\nif [ "$1" = "promise" ]; then\n  test_promise\nelse\n  test_resource_request\nfi\n'})}),"\n",(0,a.jsx)(t.p,{children:"On Promise installation, it expects a few resources to appear on the Destination, including the Redis Operator deployment. On Resource Request, it expects a new deployment for the Redis instance to appear on the Destination."}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsx)(t.p,{children:"The test script above assumes that the Destination kube context is the one currently targeted."})}),"\n",(0,a.jsxs)(t.p,{children:["You can use a similar approach to validate that all of the stages work as expected. This is especially important when stages can modify the outputs from a previous stage (like the ",(0,a.jsx)(t.code,{children:"/kratix/metadata/status.yaml"})," file)."]}),"\n",(0,a.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(t.p,{children:"Building and testing Pipelines in Kratix doesn't have to be a trial-and-error process. By treating your stages as standard software components\u2014backed by tests\u2014you gain faster feedback, greater confidence, and smoother iteration."}),"\n",(0,a.jsx)(t.p,{children:"The more you invest in testability, the faster you can move from idea to production-ready Promise. Whether you're crafting a simple configuration generator or orchestrating complex external systems, the techniques covered here help you ship robust, dependable Pipelines."}),"\n",(0,a.jsxs)(t.p,{children:["We hope this post gives you a good base on how to develop your pipelines. As always, feel free to drop by our ",(0,a.jsx)(t.a,{href:"https://kratix.slack.com",children:"Slack"})," or ",(0,a.jsx)(t.a,{href:"https://github.com/syntasso/kratix",children:"GitHub"})," to continue the conversation."]}),"\n",(0,a.jsx)(t.p,{children:"Happy shipping! \ud83d\ude80"})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var i=n(6540);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},9310:e=>{e.exports=JSON.parse('{"permalink":"/blog/local-dev-pipelines","source":"@site/blog/2025-04-22-local-dev-pipelines/index.mdx","title":"Speeding up local dev: fast feedback when building pipelines","description":"Learn how to speed up local development with fast feedback loops when building pipelines.","date":"2025-04-22T00:00:00.000Z","tags":[{"inline":true,"label":"kratix","permalink":"/blog/tags/kratix"},{"inline":true,"label":"promises","permalink":"/blog/tags/promises"},{"inline":true,"label":"pipelines","permalink":"/blog/tags/pipelines"}],"readingTime":10.81,"hasTruncateMarker":true,"authors":[{"name":"Aslan Avci","title":"Engineer @ Syntasso","url":"https://github.com/alparslanavci","imageURL":"https://github.com/alparslanavci.png","key":"aslan","page":null},{"name":"Derik Evangelista","title":"Engineer @ Syntasso","url":"https://github.com/kirederik","imageURL":"https://2.gravatar.com/avatar/7ac63fbda18c97f6a7fab8af157021367793187f4c5830eb722ff565c5a767e9?size=256","key":"derik","page":null}],"frontMatter":{"slug":"local-dev-pipelines","title":"Speeding up local dev: fast feedback when building pipelines","description":"Learn how to speed up local development with fast feedback loops when building pipelines.","authors":["aslan","derik"],"tags":["kratix","promises","pipelines"]},"unlisted":false,"prevItem":{"title":"New in Kratix: Health Checks and Progressive Rollout","permalink":"/blog/healthcheck-progressive-rollout"},"nextItem":{"title":"Kratix, Backstage, and OIDC","permalink":"/blog/backstage-and-keycloak"}}')}}]);