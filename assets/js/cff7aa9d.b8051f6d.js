"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[8040],{1653:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"ske/kratix/ske-health-agent","title":"SKE Health Agent","description":"Documentation about the SKE Health Agent","source":"@site/docs/ske/01-kratix/10-ske-health-agent.mdx","sourceDirName":"ske/01-kratix","slug":"/ske/kratix/ske-health-agent","permalink":"/ske/kratix/ske-health-agent","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/ske/01-kratix/10-ske-health-agent.mdx","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"title":"SKE Health Agent","description":"Documentation about the SKE Health Agent"},"sidebar":"skeSidebar","previous":{"title":"SKE Operator","permalink":"/ske/kratix/ske-operator"},"next":{"title":"Guides","permalink":"/category/guides-1"}}');var s=n(4848),r=n(8453);const i={title:"SKE Health Agent",description:"Documentation about the SKE Health Agent"},o=void 0,c={},l=[{value:"Features",id:"features",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Install",id:"install",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The SKE Health Agent is a health check agent to be installed in Kubernetes Destinations where health checks can be executed."}),"\n",(0,s.jsxs)(t.p,{children:["The Agent is released separately from SKE. Its releases can be found ",(0,s.jsx)(t.a,{href:"../releases/ske-health-agent",children:"here"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"features",children:"Features"}),"\n",(0,s.jsx)(t.p,{children:"The Agent will:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Schedule the execution of Health Check Workflows from the Destination"}),"\n",(0,s.jsx)(t.li,{children:"Persist the data from a health check into a state store"}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(t.p,{children:"The Agent will write the health information to a state store. The Platform cluster must have a GitOps agent listening to the state store, so the resource health can be applied back to the Platform cluster."}),"\n",(0,s.jsx)(t.h2,{id:"install",children:"Install"}),"\n",(0,s.jsx)(t.p,{children:"To install, run the command below, replacing VERSION with the target version:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"kubectl apply -f https://syntasso-enterprise-releases.s3-website.eu-west-2.amazonaws.com/#k8s-health-agent/<VERSION>/manifests/ske-health-agent.yaml\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsx)(t.p,{children:"For the SKE Health Agent to work, you will need to make sure that your Destination cluster can access the Image Registry."})}),"\n",(0,s.jsx)(t.p,{children:"You will also need to create a ConfigMap and Secret with the credentials to access the state store. The format will depend on the type os state store you wish to use. The agent currently support two different types of state stores: S3-compatible buckets and Git repositories."}),"\n",(0,s.jsx)(t.p,{children:"To configure a Git repository, create a ConfigMap and Secret with the following content:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: health-state-store-config\n  namespace: k8s-health-agent-system\ndata:\n  stateStoreKind: "GitStateStore"\n  url: # address\n  secretName: <secret name>\n  branch: # optional (default: main)\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: <secret name>\n  namespace: k8s-health-agent-system\ntype: kubernetes.io/basic-auth\nstringData:\n  # for basicAuth\n  username: # username\n  password: # password / API Token\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ssh"})," method for authentication is not currently supported."]})}),"\n",(0,s.jsx)(t.p,{children:"To configure a S3-compatible bucket, create a ConfigMap and Secret with the following content:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: health-state-store-config \n  namespace: k8s-health-agent-system\ndata:\n  stateStoreKind: "BucketStateStore"\n  endpoint: # address\n  bucketName: # bucket name\n  authMethod: # accessKey or IAM (default: accessKey)\n  secretName: <secret name> # required for accessKey\n  path: # path within the bucket; optional\n  insecure: # true or false (default: false); optional\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: <secret name>\n  namespace: k8s-health-agent-system\ntype: kubernetes.io/basic-auth\nstringData:\n  accessKeyID: # accessKey ID\n  secretAccessKey: # secret access key\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"warning",children:(0,s.jsxs)(t.p,{children:["The configuration should be created ",(0,s.jsx)(t.em,{children:"after"})," installing agent, otherwise the namespace will not exist."]})})]})}function d(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(6540);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);