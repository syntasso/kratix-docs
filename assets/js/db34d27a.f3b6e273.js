"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[2282],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},54043:e=>{e.exports=JSON.parse('{"permalink":"/blog/promise-best-practises","source":"@site/blog/2025-11-12-best-practises-for-writing-promises/index.mdx","title":"Best practices for Promise-writing","description":"Best practises to bear in mind when writing your Promises","date":"2025-11-12T00:00:00.000Z","tags":[{"inline":true,"label":"kratix","permalink":"/blog/tags/kratix"},{"inline":true,"label":"workflows","permalink":"/blog/tags/workflows"},{"inline":true,"label":"promises","permalink":"/blog/tags/promises"}],"readingTime":13.12,"hasTruncateMarker":true,"authors":[{"name":"Sapphire Mason-Brown","title":"Engineer @ Syntasso","url":"https://github.com/saphmb","imageURL":"https://github.com/saphmb.png","key":"sapphire","page":null}],"frontMatter":{"slug":"promise-best-practises","title":"Best practices for Promise-writing","description":"Best practises to bear in mind when writing your Promises","authors":["sapphire"],"tags":["kratix","workflows","promises"]},"unlisted":false,"nextItem":{"title":"Introducing the Kratix Promise-writing SDKs: Faster, Easier, More Testable","permalink":"/blog/sdk-product-announcement"}}')},89303:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=t(54043),i=t(74848),r=t(28453);const o={slug:"promise-best-practises",title:"Best practices for Promise-writing",description:"Best practises to bear in mind when writing your Promises",authors:["sapphire"],tags:["kratix","workflows","promises"]},a=void 0,l={authorsImageUrls:[void 0]},c=[];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"As platforms are so unique to organisations, and the services required by platform users are so vast, Kratix has always been very\nflexible when it comes to the design of Promises. Other than the expectation that Promise writers honour the Promise schema, the\nscope for how Promises can be designed is vast; containers can be written in any language, workflows can be as segmented as you\nwould like and workflow actions can be imperative or declarative."}),"\n",(0,i.jsx)(n.p,{children:"However, there are a number design practices and approaches to Promise development that can make development and maintenance\neasier for Promise developers and make consuming services via Promises better for users."}),"\n",(0,i.jsx)(n.p,{children:"In this blog post, we're going design a Promise with some core fundamentals in mind, paving the way for improved debugging,\nreliability and user clarity."}),"\n",(0,i.jsxs)(n.p,{children:["To get started, we're going to bootstrap our Promise. We'll be creating a Redis Promise to provision Redis instances as-a-Service.\nWe'll start by creating a new directory for our Promise and will use the ",(0,i.jsx)(n.a,{href:"/main/kratix-cli/intro",children:"kratix cli"})," to bootstrap it. Let's start by running the following commands:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir redis-promise\n\nkratix init promise redis \\\n  --group mygroup.org \\\n  --kind Redis \\\n  --version v1alpha1\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This creates a basic ",(0,i.jsx)(n.code,{children:"promise.yaml"})," and an example resource request - ",(0,i.jsx)(n.code,{children:"example-resource.yaml"})," - for our Promise. So far, this\nPromise doesn\u2019t do much, let\u2019s leverage an existing Redis operator to create instances of our Redis. To do this, the Redis\noperator, CRDs and other dependencies must exist on all destinations before the Promise can provision Redis instances."]}),"\n",(0,i.jsxs)(n.p,{children:["To start, create a directory called ",(0,i.jsx)(n.code,{children:"dependencies"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"mkdir dependencies\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then run the following to download the manifests for the redis dependencies and place them in the ",(0,i.jsx)(n.code,{children:"dependencies"})," directory."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"curl -L https://raw.githubusercontent.com/syntasso/kratix-marketplace/refs/heads/main/redis/internal/configure-pipeline/resources/dependencies/all-redis-operator-resources.yaml -o dependencies/operator-bundle.yaml\n\ncurl https://raw.githubusercontent.com/syntasso/kratix-marketplace/refs/heads/main/redis/internal/configure-pipeline/resources/dependencies/databases.spotahome.com_redisfailovers.yaml > dependencies/databases.spotahome.com_redisfailovers.yaml\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can now use the kratix cli to ensure these dependencies are installed when the Promise\u2019s Configure Pipeline runs with the\n",(0,i.jsx)(n.code,{children:"update dependencies"})," command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kratix update dependencies dependencies --image ghcr.io/syntasso/redis-dependencies:v0.0.2\n"})}),"\n",(0,i.jsx)(n.p,{children:"This command:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Places the dependencies in the ",(0,i.jsx)(n.code,{children:"workflows/promise/configure/dependencies/configure-deps/resources"})," directory"]}),"\n",(0,i.jsxs)(n.li,{children:["Creates a Dockerfile that copies the contents of the resource directory into the ",(0,i.jsx)(n.code,{children:"/kratix/outputs"})," directory so they will be\nwritten to all appropriate destinations"]}),"\n",(0,i.jsxs)(n.li,{children:["Adds the ",(0,i.jsx)(n.code,{children:"promise.configure"})," step to the ",(0,i.jsx)(n.code,{children:"pipeline.yaml"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Your directory should now look something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 dependencies\n\u2502\xa0\xa0 \u251c\u2500\u2500 databases.spotahome.com_redisfailovers.yaml\n\u2502\xa0\xa0 \u2514\u2500\u2500 operator-bundle.yaml\n\u251c\u2500\u2500 example-resource.yaml\n\u251c\u2500\u2500 promise.yaml\n\u2514\u2500\u2500 workflows\n    \u2514\u2500\u2500 promise\n        \u2514\u2500\u2500 configure\n            \u2514\u2500\u2500 dependencies\n                \u2514\u2500\u2500 configure-deps\n                    \u251c\u2500\u2500 Dockerfile\n                    \u251c\u2500\u2500 resources\n                    \u2502\xa0\xa0 \u251c\u2500\u2500 databases.spotahome.com_redisfailovers.yaml\n                    \u2502\xa0\xa0 \u2514\u2500\u2500 operator-bundle.yaml\n                    \u2514\u2500\u2500 scripts\n                        \u2514\u2500\u2500 pipeline.sh\n\n9 directories, 9 files\n"})}),"\n",(0,i.jsx)(n.p,{children:"And the promise.yaml should include the below:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"  workflows:\n    config: {}\n#highlight-start\n    promise:\n      configure:\n      - apiVersion: platform.kratix.io/v1alpha1\n        kind: Pipeline\n        metadata:\n          name: dependencies\n        spec:\n          containers:\n          - image: ghcr.io/syntasso/redis-dependencies:v0.0.2\n            name: configure-deps\n#highlight-end\n    resource: {}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now it is time to build the image that will run as part of the  ",(0,i.jsx)(n.code,{children:"promise.configure"})," step. If you are running your cluster on kind,\nyou can build and load the image to your cluster with:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"docker build --tag ghcr.io/syntasso/redis-dependencies:v0.0.1 workflows/promise/configure/dependencies/configure-deps\n\nkind load docker-image ghcr.io/syntasso/redis-dependencies:v0.0.1 --name platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can now install this early iteration of the Promise!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply --filename promise.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"You will soon see the Redis dependencies appearing on the worker cluster. Watch the operator pod as it is created with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get pods --context kind-worker --watch\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should eventually see output similar to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAME                             READY   STATUS    RESTARTS   AGE\nredisoperator-7f584c6969-zc8sx   1/1     Running   0          41s\n"})}),"\n",(0,i.jsx)(n.p,{children:"You now have a Promise that installs the Redis operator and its its dependencies but it does not yet provision Redis as-a-service"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Declarative Workflows"})}),"\n",(0,i.jsxs)(n.p,{children:["Whilst it would have been possible to install the operator and it\u2019s dependencies with ",(0,i.jsx)(n.code,{children:"kubectl apply"})," commands targeting the cluster,\nwe have chosen a ",(0,i.jsx)(n.em,{children:"declarative"})," approach; defining the desired state of the resources on the cluster and allowing the configured\nGitOps tools to converge on this desired state. Taking a declarative approach improves reliability as GitOps tools automatically\ncorrect drift, provide audibility as the configurations are declared up-front, and are more predictable."]}),"\n",(0,i.jsx)(n.p,{children:"This is also essential for ensuring that Kratix can easily delete the resources created when Promises are deleted as Kratix deletes\nthe files created as part of any configure workflows during Promise deletion."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:'This is in-keeping with the "Declare and Converge" pattern used to manage Kubernetes objects.'}),(0,i.jsxs)(n.p,{children:["You can read more about this in the ",(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/",children:"Kubernetes Documentation"})]})]}),"\n",(0,i.jsx)(n.p,{children:"At the moment, our Promise configure workflow is declarative and defines all prerequisites for installing the Redis Operator on\nthe cluster, including the CRD for the RedisFailover CR. With these installed, we can continue to to take a declarative approach\nwith our resource configure workflows - that is, what happens when a user makes a request of our redis promise."}),"\n",(0,i.jsx)(n.p,{children:"Within this workflow, we want to create a RedisFailover CR from the inputs provided by the user. There are a number of options\nthat can be configured in the RedisFailover CR but there are some defaults that we, as the Promise writers, want to enforce. The\nonly thing we want to users to be able to configure is the number of replicas and the name of their RedisFailover."}),"\n",(0,i.jsxs)(n.p,{children:["We\u2019ll take the name of the RedisFailover from the name of the user\u2019s requests and the number of replicas from the API exposed by\nthe Promise. We\u2019re going to wrap the number of replicas in a simple abstraction where ",(0,i.jsx)(n.code,{children:"small"})," is one replica and ",(0,i.jsx)(n.code,{children:"large"})," is three;\nwe can implement the logic for this in our workflow which we\u2019ll introduce shortly."]}),"\n",(0,i.jsxs)(n.p,{children:["First, we\u2019re going to update the Promise API to introduce the ",(0,i.jsx)(n.code,{children:"size"})," property. We can do this with the ",(0,i.jsx)(n.code,{children:"update api"})," command:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kratix update api --property size:string\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You should see that the following has been added to the ",(0,i.jsx)(n.code,{children:"promise.yaml"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"  api:\n    apiVersion: apiextensions.k8s.io/v1\n    kind: CustomResourceDefinition\n    metadata:\n      creationTimestamp: null\n      name: rediss.mygroup.org\n    spec:\n      group: mygroup.org\n      names:\n        kind: Redis\n        plural: rediss\n        singular: redis\n      scope: Namespaced\n      versions:\n      - name: v1alpha1\n        schema:\n          openAPIV3Schema:\n            properties:\n              spec:\n                properties:\n                  size:\n                    type: string\n                type: object\n            type: object\n        served: true\n        storage: true\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can now add a workflow that uses to this property. Again, we can use the kratix cli - this time with the ",(0,i.jsx)(n.code,{children:"add container"}),"\ncommand:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kratix add container resource/configure/instance-configure --image ghcr.io/syntasso/redis-dependencies:v0.0.1 --language go\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will have updated the ",(0,i.jsx)(n.code,{children:"promise.yaml"})," to add a ",(0,i.jsx)(n.code,{children:"resource.configure"})," workflow and have bootstrapped a Docker image that can be\nbuilt to run as part of this workflow. As we has specified that we want to use the ",(0,i.jsx)(n.a,{href:"https://pkg.go.dev/github.com/syntasso/kratix-go",children:"kratix-go sdk"})," for this Promise via the ",(0,i.jsx)(n.code,{children:"--language"}),"\nflag, we also have a ",(0,i.jsx)(n.code,{children:"pipeline.go"})," file. Update the script to contain the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n\t"fmt"\n\n\tkratix "github.com/syntasso/kratix-go"\n)\n\nfunc main() {\n\tsdk := kratix.New()\n\tresource, _ := sdk.ReadResourceInput()\n\tname := resource.GetName()\n\tsize, err := resource.GetValue("spec.size")\n\tif err != nil {\n\t\tlog.Fatalf("failed fetch \'size\' property from request: %v", err)\n\t}\n\t\n\tvar replicas int\n\tif size == "small" {\n\t\treplicas = 1\n\t}\n\t\n\tif size == "large" {\n\t\treplicas = 3\n\t}\n\t\n\tfailoverTemplate := `apiVersion: databases.spotahome.com/v1\nkind: RedisFailover\nmetadata:\n  name: %s\n  namespace: default\nspec:\n  redis:\n    imagePullPolicy: IfNotPresent\n    replicas: %d\n    customConfig:\n      - "maxclients 100"\n      - "hz 50"\n      - "timeout 60"\n      - "tcp-keepalive 60"\n      - "client-output-buffer-limit normal 0 0 0"\n      - "client-output-buffer-limit slave 1000000000 1000000000 0"\n      - "client-output-buffer-limit pubsub 33554432 8388608 60"\n    resources:\n      limits:\n        cpu: 400m\n        memory: 500Mi\n      requests:\n        cpu: 100m\n        memory: 100Mi\n  sentinel:\n    imagePullPolicy: IfNotPresent\n    replicas: %d\n    customConfig:\n      - "down-after-milliseconds 2000"\n      - "failover-timeout 3000"\n    resources:\n      limits:\n        memory: 100Mi\n      requests:\n        cpu: 100m\n`\n\t\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, replicas, replicas))\n\t\n\t\tsdk.WriteOutput("redis_failover.yaml", redisContent)\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"We\u2019re going to execute this script when creating and updating a resource request. It will:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Retrieve the name and size of the Redis from the resource request"}),"\n",(0,i.jsx)(n.li,{children:"Interpolate these in the template for the generated redis failover alongside the configured defaults"}),"\n",(0,i.jsxs)(n.li,{children:["Write the RedisFailover CR to the ",(0,i.jsx)(n.code,{children:"/kratix/output"})," directory so it can be written to a destination."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"As this workflow is written declaratively, there will be no attempts to create the Redis after initial creation. It will only be\nupdated if there is a change in the specification of the resource."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Idempotency"})}),"\n",(0,i.jsxs)(n.p,{children:["Idempotency refers to the ability to run an action multiple times with the guarantee that there will be no additional effect of\nrunning after it the initial action. In our case, if the resource configure workflow runs a second or third time, no additional\nRedis instance will be created on these occasions. This is part of what having a declarative workflow enables. As the workflow\ndescribes the ",(0,i.jsx)(n.em,{children:"desired"})," Redis instance, if the workflow re-runs for any reason, the Redis will not be created again. It will\nhowever, be updated if there are any changes to the request."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Error Handling"})}),"\n",(0,i.jsx)(n.p,{children:"When writing Promise workflows, correct error handling is essential and we must ensure that, should an error occur, the container\nexits with a non-zero exit code."}),"\n",(0,i.jsx)(n.p,{children:"Take a look at this part of our script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, size, size))\n\tsdk.WriteOutput("redis_failover.yaml", redisContent)\t\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The go SDK\u2019s ",(0,i.jsx)(n.code,{children:"WriteOutput"})," function returns an error if for any reason, we are unable to write output to a file. However, at\npresent, we are not checking if an error arises and do not exit if it does. In this form, the write could fail, the container\nwould exit and we wouldn\u2019t notice that something had gone wrong until the RedisFailover failed to appear on the destination."]}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s mitigate against exactly this, update the workflow with the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, size, size))\n\t\n\terr = sdk.WriteOutput("redis_failover.yaml", redisContent)\n\tif err != nil {\n\t\tlog.Fatalf("failed to write output: %v", err)\n\t}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The script will now exit with an error if one is returned by the ",(0,i.jsx)(n.code,{children:"WriteOutput"})," function. Now, if the write fails it is immediately obvious from the execution of the workflow pod as it will fail."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Informing users via the status"})}),"\n",(0,i.jsxs)(n.p,{children:["When users make a request, as Promise writers we can be as specific as we would like about the information we would like to\nsurface to users about their request. For some resources, this can include details about how to access a given service with a url\nor database string for instance. We\u2019re going to do something more simple, when the ",(0,i.jsx)(n.code,{children:"redis_failover.yaml"})," has been successfully\nwritten to the outputs, we\u2019re going to inform users that it is in the \u201cProvisioning\u201d stage so they know that their request is in\nprogress."]}),"\n",(0,i.jsx)(n.p,{children:"We can do this with the SDK. Add the following to the end of the workflow script:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'\tstatus := kratix.NewStatus()\n\tstatus.Set("stage", "provisioning")\n\tif err := sdk.WriteStatus(status); err != nil {\n\t\tlog.Fatalf("failed to write status: %v", err)\n\t}\n'})}),"\n",(0,i.jsx)(n.p,{children:"This part of the workflow:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Creates a status"}),"\n",(0,i.jsxs)(n.li,{children:["Sets the key and value ",(0,i.jsx)(n.code,{children:"stage: provisioning"})," on the status"]}),"\n",(0,i.jsxs)(n.li,{children:["Writes the status as a ",(0,i.jsx)(n.code,{children:"status.yaml"})," file to the ",(0,i.jsx)(n.code,{children:"metadata"})," directory"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"status.yaml"})," file is written to the metadata directory, Kratix will automatically persist that information to the status\nof the Resource."]}),"\n",(0,i.jsx)(n.p,{children:"This  status-writing happens at the end of the workflow, but what if there is a failure earlier in the workflow? How can we inform\nthe user that something has gone wrong? In these error cases, we can update the status by patching the resource directly via the\nAPI."}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s revisit the previous example of error handling:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, size, size))\n\t\n\terr := sdk.WriteOutput("redis_failover.yaml", redisContent)\n\tif err != nil {\n\t\tlog.Fatalf("failed to write output: %v", err)\n\t}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If the ",(0,i.jsx)(n.code,{children:"WriteOutput"})," function fails, we want to ensure that an error in provisioning is surfaced in the status of the requested resource. Update the script with the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, size, size))\n\n\terr := sdk.WriteOutput("redis_failover.yaml", redisContent)\n\tif err != nil {\n#highlight-start\n\t\tstatus := kratix.NewStatus()\n\t\tstatus.Set("stage", "provisioning error")\n\t\tif err := sdk.PublishStatus(resource, status); err != nil {\n\t\t\tlog.Fatalf("failed to publish status: %v", err)\n\t\t}\n#highlight-end\n\t\tlog.Fatalf("failed to write output: %v", err)\n\t}\n'})}),"\n",(0,i.jsx)(n.p,{children:"If an error occurs when writing the output, before exiting the container we are now:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Creating a status and setting the ",(0,i.jsx)(n.code,{children:"stage"})," to ",(0,i.jsx)(n.code,{children:"provisioning error"})]}),"\n",(0,i.jsxs)(n.li,{children:["Calling ",(0,i.jsx)(n.code,{children:"PublishStatus"})," to update the resource directly. The ",(0,i.jsx)(n.code,{children:"PublishStatus"})," function performs a patch of the resource."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ensures that even in scenarios where errors occur, we still communicate the status of the resource to users."}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Click here"})," for the full ",(0,i.jsx)(n.code,{children:"pipeline.go"})," file."]})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n\t"fmt"\n\t"log"\n\n\tkratix "github.com/syntasso/kratix-go"\n)\n\nfunc main() {\n\tsdk := kratix.New()\n\tresource, _ := sdk.ReadResourceInput()\n\tname := resource.GetName()\n\tsize, err := resource.GetValue("spec.size")\n\tif err != nil {\n\t\tlog.Fatalf("failed fetch \'size\' property from request: %v", err)\n\t}\n\n\tvar replicas int\n\tif size == "small" {\n\t\treplicas = 1\n\t}\n\n\tif size == "large" {\n\t\treplicas = 3\n\t}\n\n\tfailoverTemplate := `apiVersion: databases.spotahome.com/v1\nkind: RedisFailover\nmetadata:\n  name: %s\n  namespace: default\nspec:\n  redis:\n    imagePullPolicy: IfNotPresent\n    replicas: %d\n    customConfig:\n      - "maxclients 100"\n      - "hz 50"\n      - "timeout 60"\n      - "tcp-keepalive 60"\n      - "client-output-buffer-limit normal 0 0 0"\n      - "client-output-buffer-limit slave 1000000000 1000000000 0"\n      - "client-output-buffer-limit pubsub 33554432 8388608 60"\n    resources:\n      limits:\n        cpu: 400m\n        memory: 500Mi\n      requests:\n        cpu: 100m\n        memory: 100Mi\n  sentinel:\n    imagePullPolicy: IfNotPresent\n    replicas: %d\n    customConfig:\n      - "down-after-milliseconds 2000"\n      - "failover-timeout 3000"\n    resources:\n      limits:\n        memory: 100Mi\n      requests:\n        cpu: 100m\n`\n\n\tredisContent := []byte(fmt.Sprintf(failoverTemplate, name, replicas, replicas))\n\n\terr = sdk.WriteOutput("redis_failover.yaml", redisContent)\n\tif err != nil {\n\t\tstatus := kratix.NewStatus()\n\t\tstatus.Set("stage", "provisioning error")\n\t\tif err := sdk.PublishStatus(resource, status); err != nil {\n\t\t\tlog.Fatalf("failed to publish status: %v", err)\n\t\t}\n\t\tlog.Fatalf("failed to write output: %v", err)\n\t}\n\n\tstatus := kratix.NewStatus()\n\tstatus.Set("stage", "provisioning")\n\tif err := sdk.WriteStatus(status); err != nil {\n\t\tlog.Fatalf("failed to write status: %v", err)\n\t}\n}\n\n'})})]}),"\n",(0,i.jsx)(n.p,{children:"We are now ready to build this image and make our first resource request for a redis-as-a-service."}),"\n",(0,i.jsx)(n.p,{children:"Let\u2019s start by initialising the go modules for the script and building the image:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"pushd workflows/resource/configure/instance-configure/ghcr-io-syntasso-redis-configure/scripts\n\tgo mod init syntasso/redis-configure\ngo mod tidy\npopd\n\ndocker build --tag ghcr.io/syntasso/redis-configure:v0.0.1 workflows/resource/configure/instance-configure/ghcr-io-syntasso-redis-configure/\n\nkind load docker-image ghcr.io/syntasso/redis-configure:v0.0.1 --name platform\n"})}),"\n",(0,i.jsx)(n.p,{children:"With the image built and loaded in our environment, we are now ready to make a resource request."}),"\n",(0,i.jsxs)(n.p,{children:["Update the ",(0,i.jsx)(n.code,{children:"example-resource.yaml"})," to specify a size:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"apiVersion: mygroup.org/v1alpha1\nkind: Redis\nmetadata:\n  name: example-redis\n#highlight-start\nspec:\n  size: small\n#highlight-end\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we can use the ",(0,i.jsx)(n.code,{children:"kubectl"})," cli to apply this request:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl apply --file example-resource.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"Shortly, we should begin to see the Redis pods starting on the worker cluster. Let's check with:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl get pods --context kind-worker\n"})}),"\n",(0,i.jsx)(n.p,{children:"You should see something similar to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"NAMESPACE            NAME                                           READY   STATUS    RESTARTS       AGE\ndefault              redisoperator-7f584c6969-7hh9z                 1/1     Running   0              10m\ndefault              rfr-example-redis-0                            1/1     Running   0              75s\ndefault              rfs-example-redis-79c8b8c977-fdv9x             1/1     Running   0              75s\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Additionally, the resource request should detail that it is in a ",(0,i.jsx)(n.code,{children:"provisioning"})," state. Run:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"kubectl describe redis example-redis\n"})}),"\n",(0,i.jsx)(n.p,{children:"The status should show the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"  Last Successful Configure Workflow Time:  2025-11-11T14:40:07Z\n  Message:                                  Resource requested\n  Observed Generation:                      1\n#highlight-start\n  Stage:                                    provisioning\n#highlight-end\n  Workflows:                                1\n  Workflows Failed:                         0\n  Workflows Succeeded:                      1 \n"})}),"\n",(0,i.jsx)(n.p,{children:"Congratulations! You have written a Promise that employs some of the best practices for Promise implementation; declarative\nworkflows, idempotency, correct error handling, and effective use of the resource status. With these in mind, you\u2019ll create\nPromises that are easier to debug and update, and provide a better experience for consumers."}),"\n",(0,i.jsxs)(n.p,{children:["If you've got more questions about how to write your Promises, don't hesitate to reach out to us and the Kratix community via\nthe ",(0,i.jsx)(n.a,{href:"https://kratixworkspace.slack.com/",children:"Kratix Community Slack"}),"! We'd love to hear from you."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);