"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[7869],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(96540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}},83836:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"main/platform-concepts/private-image-registries","title":"Private Image Registries","description":"Use private registries with Kratix deployments and workflow images.","source":"@site/docs/main/05-platform-concepts/07-private-image-registries.mdx","sourceDirName":"main/05-platform-concepts","slug":"/main/platform-concepts/private-image-registries","permalink":"/main/platform-concepts/private-image-registries","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-platform-concepts/07-private-image-registries.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"title":"Private Image Registries","description":"Use private registries with Kratix deployments and workflow images."},"sidebar":"mainSidebar","previous":{"title":"Multi-tenancy","permalink":"/main/platform-concepts/multi-tenancy"},"next":{"title":"Identity and Access","permalink":"/category/identity-and-access"}}');var s=t(74848),i=t(28453);const a={title:"Private Image Registries",description:"Use private registries with Kratix deployments and workflow images."},o=void 0,c={},l=[{value:"Workflow images",id:"workflow-images",level:2},{value:"Namespace scope and syncing",id:"namespace-scope-and-syncing",level:2},{value:"Cluster-wide options",id:"cluster-wide-options",level:2},{value:"Air-gapped environments",id:"air-gapped-environments",level:2}];function p(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Kratix workflows pull images like any other Kubernetes workload. If your\ncluster needs private registry access, use ",(0,s.jsx)(n.code,{children:"imagePullSecrets"}),". See the\nKubernetes docs on ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/",children:"pulling images from a private registry"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"workflow-images",children:"Workflow images"}),"\n",(0,s.jsxs)(n.p,{children:["Promise workflows run in the ",(0,s.jsx)(n.code,{children:"kratix-platform-system"})," namespace and resource\nworkflows run in the resource request namespace. For private images, create an\nimage pull secret in the relevant namespace and reference it in the Pipeline\nspec via ",(0,s.jsx)(n.code,{children:"imagePullSecrets"}),". That ensures the workflow Job can pull all of the\ncontainer images it needs."]}),"\n",(0,s.jsx)(n.p,{children:"Example Pipeline snippet:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"platform: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: example\nspec:\n  workflows:\n    resource:\n      configure:\n      - apiVersion: platform.kratix.io/v1alpha1\n        kind: Pipeline\n        metadata:\n          name: build\n        spec:\n          containers:\n          - name: runner\n            image: registry.example.com/team/tooling:1.2.3\n          imagePullSecrets:\n          - name: registry-creds\n"})}),"\n",(0,s.jsx)(n.h2,{id:"namespace-scope-and-syncing",children:"Namespace scope and syncing"}),"\n",(0,s.jsxs)(n.p,{children:["Image pull secrets are namespace-scoped, so each namespace that runs workflows\nneeds access to the right ",(0,s.jsx)(n.code,{children:"Secret"}),". In practice, this often means copying or\nsyncing the same credentials into multiple namespaces. A common approach is to\nuse a secrets operator that can source credentials from a central store (like a\ncloud secret manager or Vault) and fan them out into the namespaces that need\nthem. This keeps the source of truth centralized while still meeting the\nnamespace scoping rules."]}),"\n",(0,s.jsx)(n.h2,{id:"cluster-wide-options",children:"Cluster-wide options"}),"\n",(0,s.jsxs)(n.p,{children:["Some clusters configure registry access at the node level so workloads do not\nneed per-namespace secrets. For example, you can use kubelet image credential\nproviders to supply credentials based on the image registry, or configure\nregistry mirrors so nodes pull from a trusted internal endpoint. This can\nsimplify per-namespace management, but it also broadens who can use those\ncredentials: any workload scheduled on the node can pull from the registry. Use\nthis approach only when that risk is acceptable for your environment. See the\nKubernetes docs on\n",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/kubelet-credential-provider/",children:"image credential providers"}),"\nfor an overview."]}),"\n",(0,s.jsx)(n.h2,{id:"air-gapped-environments",children:"Air-gapped environments"}),"\n",(0,s.jsxs)(n.p,{children:["If you are running in an air-gapped environment or need to mirror registries,\nthe SKE ",(0,s.jsx)(n.a,{href:"/ske/installing-ske/air-gapped",children:"air-gapped installation"})," guide walks\nyou through the setup. SKE handles much of the heavy lifting around registry\nmirrors and offline artifacts, so you can focus on your platform workflows\ninstead of the plumbing."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}}}]);