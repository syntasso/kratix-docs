"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[9440],{590:e=>{e.exports=JSON.parse('{"permalink":"/blog/compound-promises","source":"@site/blog/2025-02-13-compound-promises/index.mdx","title":"How to write Compound Promises","description":"Everything you need to know about building Compound Promises effectively","date":"2025-02-13T00:00:00.000Z","tags":[{"inline":true,"label":"kratix","permalink":"/blog/tags/kratix"},{"inline":true,"label":"promises","permalink":"/blog/tags/promises"},{"inline":true,"label":"compound promise","permalink":"/blog/tags/compound-promise"}],"readingTime":19.09,"hasTruncateMarker":true,"authors":[{"name":"Derik Evangelista","title":"Engineer @ Syntasso","url":"https://github.com/kirederik","imageURL":"https://2.gravatar.com/avatar/7ac63fbda18c97f6a7fab8af157021367793187f4c5830eb722ff565c5a767e9?size=256","key":"derik","page":null}],"frontMatter":{"slug":"compound-promises","title":"How to write Compound Promises","description":"Everything you need to know about building Compound Promises effectively","authors":["derik"],"tags":["kratix","promises","compound promise"]},"unlisted":false,"prevItem":{"title":"Debugging in Kratix","permalink":"/blog/debugging-promise-updates"},"nextItem":{"title":"How your Resources get from Promise to Destination","permalink":"/blog/from-platform-to-destination"}}')},1601:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>p,contentTitle:()=>h,default:()=>g,frontMatter:()=>c,metadata:()=>t,toc:()=>m});var t=i(590),s=i(4848),a=i(8453);const r=i.p+"assets/images/figure00-40fe147887766a3857227d9893d6106f.png",o=i.p+"assets/images/figure02-e8eb90402c3fc97671f2b9098637fc46.png",l=i.p+"assets/images/figure03-0baa807bcc7d6f29f582dae39ca56be7.png",d=i.p+"assets/images/running-app-66ddb8ccd0482bc559ed5c2a86b9c015.png",c={slug:"compound-promises",title:"How to write Compound Promises",description:"Everything you need to know about building Compound Promises effectively",authors:["derik"],tags:["kratix","promises","compound promise"]},h=void 0,p={authorsImageUrls:[void 0]},m=[{value:"Defining the user experience",id:"defining-the-user-experience",level:2},{value:"Building the Compound Promise",id:"building-the-compound-promise",level:2},{value:"Implementing the API",id:"implementing-the-api",level:3},{value:"Implementing the Workflow",id:"implementing-the-workflow",level:3},{value:"Adding the Runtime Request",id:"adding-the-runtime-request",level:4},{value:"Adding the PostgreSQL Request",id:"adding-the-postgresql-request",level:4},{value:"Adding the Redis Request",id:"adding-the-redis-request",level:4},{value:"Scheduling to the Platform cluster",id:"scheduling-to-the-platform-cluster",level:3},{value:"Defining the Promise Requirements",id:"defining-the-promise-requirements",level:3},{value:"Installing the Promise",id:"install",level:2},{value:"Testing it all together",id:"testing-it-all-together",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["So you read the ",(0,s.jsx)(n.a,{href:"/main/guides/compound-promises",children:"guide"})," on Compound Promises and tried out the Workshop, and decided that a compound promise is the right abstraction to expose in your platform. You are about to start writing it, but you are still wondering how you would ",(0,s.jsx)(n.em,{children:"really"})," go about writing one."]}),"\n",(0,s.jsx)(n.p,{children:"We hear you."}),"\n",(0,s.jsx)(n.p,{children:"In this blog post, we will build a Compound Promise from scratch. Consider this the ultimate guide on how to build compound promises effectively."}),"\n",(0,s.jsxs)(n.p,{children:["You can follow this guide and build the Promise along with us, or you can use it as a reference when building your own Compound Promises. The Promise we will build is available ",(0,s.jsx)(n.a,{href:"https://github.com/syntasso/kratix-docs/tree/main/assets/rubyapp-promise",children:"here"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"After reading this post you will:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Learn about some basic Kratix concepts"}),"\n",(0,s.jsxs)(n.li,{children:["Learn how to write a Compound Promise","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"By transforming an user's request into a series of sub-requests"}),"\n",(0,s.jsx)(n.li,{children:"By sending those sub-requests to the Platform cluster (and why you need it)"}),"\n",(0,s.jsx)(n.li,{children:"By defining the sub-Promises that the parent Promise depends on"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'Click on "read more" to continue!'}),"\n","\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"Before we start, let's clarify a few words we will use in abundance throughout this article:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Promise"}),": The basic building block in Kratix. A Promise defines something-as-a-service. If you're unfamiliar with Promises, we recommend reading our documentation, such as ",(0,s.jsx)(n.a,{href:"/main/guides/installing-a-promise",children:"Installing and using a Promise"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Workflow"}),": defined within a Promise, it transforms the user's request into reality."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Compound Promise"}),': a Promise that orchestrates one or more Promises. We may refer to it as "the parent promise" or "the super promise" in this article.',"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:'The Promises that a Compound Promise is orchestrating may be referred to as "child promises" or "sub-promises".'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now that we understand each other, let's dive into, well, the reason you are here: building a compound promise. I'm going to split this article into the following sections:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Defining the user experience."}),"\n",(0,s.jsxs)(n.li,{children:["Building the Compound Promise.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implementing the API."}),"\n",(0,s.jsx)(n.li,{children:"Implementing the workflows."}),"\n",(0,s.jsx)(n.li,{children:"Scheduling to the Platform Cluster."}),"\n",(0,s.jsx)(n.li,{children:"Defining the Promise requirements."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Installing the Promise"}),"\n",(0,s.jsx)(n.li,{children:"Testing it all together"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Let's jump right in!"}),"\n",(0,s.jsx)(n.h2,{id:"defining-the-user-experience",children:"Defining the user experience"}),"\n",(0,s.jsx)(n.p,{children:"As previously mentioned, a compound promise orchestrates one or more promises to provide a higher-level developer experience. Imagine a platform like Heroku or Fly.io: they make it very easy for developers to get off the ground and quickly get their applications up and running in the cloud. On the other hand, they still give users the necessary hooks to tweak configurations so they can get exactly what they need."}),"\n",(0,s.jsxs)(n.p,{children:["For example, to deploy a Rails application to ",(0,s.jsx)(n.a,{href:"https://fly.io/docs/rails/getting-started/existing/",children:"fly.io"}),", all the user needs to do is execute a command using the ",(0,s.jsx)(n.code,{children:"flyctl"})," CLI. That command Will interactively ask the user for inputs, like if they need a PostgreSQL database and a Redis cache to be deployed with the application, and, depending on their answers, it will create and deploy the necessary resources. It will also make sure that the running application is wired correctly to the services. Once everything is created, the user will get back an URL with the address of their running application (and services)."]}),"\n",(0,s.jsx)(n.p,{children:"Kratix makes building a similar experience in your internal platform as easy. While it is possible to build all of that in a single Promise, a better approach is to build smaller, single-responsibility Promises\u2013like a dedicated PostgreSQL Promise\u2013and then create a Promise at a higher-level of abstraction that orchestrates requesting the lower-level resources. That higher-level Promise is what we are going to build."}),"\n",(0,s.jsx)(n.p,{children:"And what will this Promise do? Well, provide the exact same experience to deploy Rails applications as fly.io:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Given an container image of an application, the Promise should deploy it."}),"\n",(0,s.jsxs)(n.li,{children:["If required by the user, they can also deploy:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A PostgreSQL database."}),"\n",(0,s.jsx)(n.li,{children:"A Redis cache."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"The Promise should wire the application with the connection details of the optional services."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Luckily, all the sub-promises you need to build this Compound Promise are available in the ",(0,s.jsx)(n.a,{href:"/marketplace",children:"Kratix Marketplace"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The Runtime Promise can deploy applications;"}),"\n",(0,s.jsx)(n.li,{children:"The PostgreSQL Promise can deploy PostgreSQL databases;"}),"\n",(0,s.jsx)(n.li,{children:"The Redis Promise can be our cache provider;"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"All the Compound Promise\u2014let's call it the RubyApp Promise\u2014needs to do is orchestrate requests to those other promises."}),"\n","\n",(0,s.jsxs)("figure",{className:"diagram",children:[(0,s.jsx)("img",{className:"large",src:r,alt:"The RubyApp Promise interacting with sub-promises"}),(0,s.jsx)("figcaption",{children:"RubyApp Promise orchestrating the sub-promises"})]}),"\n",(0,s.jsx)(n.p,{children:"In order to create this experience, we must start by considering what's going to be the RubyApp Promise API: What can the users configure? What's the right level of abstraction? Do we give more configuration options and risk it being too complex, or keep it high-level and risk it being too limiting?"}),"\n",(0,s.jsxs)(n.p,{children:["As with many good questions in life, the answer is: ",(0,s.jsx)(n.em,{children:"it depends"}),". Circling back to the developer experience we want to provide, there are benefits in keeping things as simple as possible. The beauty of Compound Promises is that users can still directly use lower-level Promises. This characteristic allows Platform engineers to offer multiple ways of consuming services. The 80/20 rule is a good principle to keep in mind:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"What would be an API that would satisfy 80% of the use-cases of the RubyApp Promise?"}),"\n",(0,s.jsx)(n.li,{children:"The remaining 20% could consume the lower-level Promises directly."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Alright, with that in mind, what should we include in the API?"}),"\n",(0,s.jsx)(n.p,{children:"At the most basic level, we need the application to run. Since we will run it in Kubernetes, this could be provided as a container image. We also need a way for users to specify whether they require a database or a cache (or both)."}),"\n",(0,s.jsx)(n.p,{children:"So our API is starting to form. Something like this may be enough to get us started:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"image: container/myapp:v1.0.0\ndatabase: true\ncache: false\n"})}),"\n",(0,s.jsx)(n.p,{children:"However, thinking a bit ahead, we can imagine a scenario where users would want a different type of database (like MySQL instead of PostgreSQL), or provide some extra configuration for the it. A better API would leave the options opened, so in the future we could expand on the options. Something like this would be better:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"image: myorg/ruby-app:v1.0.0\ndatabase:\n  driver: postgresql\ncache:\n  driver: redis\n"})}),"\n",(0,s.jsx)(n.p,{children:"If we translate this to a resource request of the RubyApp Promise, it may look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: internal.platform.io/v1\nkind: RubyApp\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  image: myorg/ruby-app:v1.0.0\n  database:\n    driver: postgresql\n  cache:\n    driver: redis\n"})}),"\n",(0,s.jsx)(n.p,{children:"With the experience defined, we can now start building the Promise."}),"\n",(0,s.jsx)(n.h2,{id:"building-the-compound-promise",children:"Building the Compound Promise"}),"\n",(0,s.jsxs)(n.admonition,{title:"Skip the build!",type:"tip",children:[(0,s.jsx)(n.p,{children:"You can follow this guide and build the Promise along with us, or you can use it as a reference when building your own Compound Promises."}),(0,s.jsxs)(n.p,{children:["The Promise mentioned in this post is available ",(0,s.jsx)(n.a,{href:"https://github.com/syntasso/kratix-docs/tree/main/assets/rubyapp-promise",children:"here"}),"."]}),(0,s.jsxs)(n.p,{children:["You can skip straight to ",(0,s.jsx)(n.a,{href:"#install",children:"installing the Promise"})," if you want to see it in action."]})]}),"\n",(0,s.jsx)(n.h3,{id:"implementing-the-api",children:"Implementing the API"}),"\n",(0,s.jsxs)(n.p,{children:["With the API and experience defined, let's create the RubyApp Promise. We can use the ",(0,s.jsx)(n.a,{href:"/main/kratix-cli/intro",children:"Kratix CLI"})," to speed up development. Create a new directory in your system and initialise a new Promise:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"mkdir rubyapp-promise && cd rubyapp-promise\n\nkratix init promise rubyapp \\\n  --group internal.platform.io \\\n  --kind RubyApp \\\n  --version v1\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The command above should produce a ",(0,s.jsx)(n.code,{children:"promise.yaml"})," in the ",(0,s.jsx)(n.code,{children:"rubyapp-promise"})," directory. We can now add the API properties we defined above:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kratix update api \\\n  --property image:string \\\n  --property database.driver:string \\\n  --property cache.driver:string\n"})}),"\n",(0,s.jsx)(n.p,{children:"The next step is to implement the workflow that will transform the user's request into the sub-promises request."}),"\n",(0,s.jsx)(n.h3,{id:"implementing-the-workflow",children:"Implementing the Workflow"}),"\n",(0,s.jsxs)(n.p,{children:["To quick-start the workflow, run the ",(0,s.jsx)(n.code,{children:"kratix add container"})," command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kratix add container resource/configure/instance \\\n  --image ghcr.io/syntasso/kratix-docs/rubyapp-promise:v1.0.0 \\\n  --name deploy-resources\n"})}),"\n",(0,s.jsxs)(n.p,{children:["At this point, your local ",(0,s.jsx)(n.code,{children:"rubyapp-promise"})," directory should look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:".\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 example-resource.yaml\n\u251c\u2500\u2500 promise.yaml\n\u2514\u2500\u2500 workflows\n    \u2514\u2500\u2500 resource\n        \u2514\u2500\u2500 configure\n            \u2514\u2500\u2500 instance\n                \u2514\u2500\u2500 deploy-resources\n                    \u251c\u2500\u2500 Dockerfile\n                    \u251c\u2500\u2500 resources\n                    \u2514\u2500\u2500 scripts\n                        \u2514\u2500\u2500 pipeline.sh\n\n8 directories, 5 files\n"})}),"\n",(0,s.jsx)(n.p,{children:"A quick recap of what the pipeline script should do:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Deploy the application specified with the specified image, via the Runtime Promise"}),"\n",(0,s.jsxs)(n.li,{children:["Create a PostgreSQL instance if ",(0,s.jsx)(n.code,{children:"database.driver"})," is set to ",(0,s.jsx)(n.code,{children:"postgresql"}),", via the PostgreSQL Promise"]}),"\n",(0,s.jsxs)(n.li,{children:["Create a Redis instance if ",(0,s.jsx)(n.code,{children:"cache.driver"})," is set to ",(0,s.jsx)(n.code,{children:"redis"}),", via the Redis Promise."]}),"\n",(0,s.jsx)(n.li,{children:"Update the application environment variables with the credentials for the optional services."}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"adding-the-runtime-request",children:"Adding the Runtime Request"}),"\n",(0,s.jsxs)(n.p,{children:["Let's start from the start and add the first requirement. To deploy the application via the Runtime Promise, the pipeline must output a Resource Request for that Promise. The ",(0,s.jsx)(n.a,{href:"https://github.com/syntasso/kratix-marketplace/blob/main/runtime/resource-request.yaml",children:"API for the Runtime Promise"})," looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: marketplace.kratix.io/v1alpha1\nkind: Runtime\nmetadata:\n  name: example-runtime\n  namespace: default\nspec:\n  lifecycle: dev\n  image: syntasso/website\n  servicePort: 80\n  replicas: 1\n  applicationEnv:\n  - name: hello\n    value: from-env\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, the only configuration option we are currently providing in the API of our RubyApp promise is the image. All the other fields should either be populated by the RubyApp workflow, or left empty. We must also ensure the ",(0,s.jsx)(n.code,{children:"metadata.name"})," we generate for this request is unique, otherwise it may clash with other resources already deployed."]}),"\n",(0,s.jsxs)(n.p,{children:["Since our pipeline script will be a bit complex, let's implement it using Ruby. For that, open the ",(0,s.jsx)(n.code,{children:"Dockerfile"})," in ",(0,s.jsx)(n.code,{children:"workflows/resource/configure/instance/deploy-resources/"})," and add ",(0,s.jsx)(n.code,{children:"ruby"})," to your container. You should change the extension of the ",(0,s.jsx)(n.code,{children:"pipeline.sh"})," to ",(0,s.jsx)(n.code,{children:"pipeline.rb"})," as well."]}),"\n",(0,s.jsx)(n.p,{children:"The resulting Dockerfile will look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dockerfile",children:'FROM "alpine"\n\nRUN apk update && apk add --no-cache yq ruby\n\nADD scripts/pipeline.rb /usr/bin/pipeline.rb\nADD resources resources\n\nRUN chmod +x /usr/bin/pipeline.rb\n\nCMD [ "sh", "-c", "pipeline.rb" ]\nENTRYPOINT []\n'})}),"\n",(0,s.jsx)(n.p,{children:"Update the extension of the pipeline script in your filesystem:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"mv workflows/resource/configure/instance/deploy-resources/scripts/pipeline.{sh,rb}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Now open the ",(0,s.jsx)(n.code,{children:"pipeline.rb"})," script in ",(0,s.jsx)(n.code,{children:"workflows/resource/configure/instance/deploy-resources/scripts"})," and update it to:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"#!/usr/bin/env ruby\n\nrequire 'yaml'\n\n# Read the input YAML file\ninput_yaml = YAML.load_file('/kratix/input/object.yaml')\n\n# Extract values from input\napp_name = input_yaml['metadata']['name']\nnamespace = input_yaml['metadata']['namespace']\napp_image = input_yaml['spec']['image']\n\n# Create the Runtime request\nruntime_request = {\n  'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n  'kind' => 'Runtime',\n  'metadata' => {\n    'name' => app_name,\n    'namespace' => namespace\n  },\n  'spec' => {\n    'image' => app_image,\n    'replicas' => 1,\n    'servicePort' => 80,\n    'applicationEnv' => [\n      { 'name' => 'PORT', 'value' => '80' }\n    ]\n  }\n}\n\n# Write to Runtime request to the output file\nFile.write('/kratix/output/runtime-request.yaml', runtime_request.to_yaml)\n"})}),"\n",(0,s.jsx)(n.p,{children:"As you can see, we have hidden away from the RubyApp user a few options the Runtime Promise provides, like replicas and service port. In your own organisation, those options may need to be exposed at the higher-level Promise."}),"\n",(0,s.jsx)(n.h4,{id:"adding-the-postgresql-request",children:"Adding the PostgreSQL Request"}),"\n",(0,s.jsx)(n.p,{children:"Next step is to optionally include a request to the PostgreSQL Promise if the user requested a database. The API for the PostgreSQL Promise looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: marketplace.kratix.io/v1alpha1\nkind: postgresql\nmetadata:\n  name: example\n  namespace: default\nspec:\n  env: dev\n  teamId: acid\n  dbName: bestdb\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Back in the pipeline script, let's update it to include this request when needed. We should also make sure to include the connection details as environment variables to our Runtime request, so the application can connect. Add the following code snippet just after the ",(0,s.jsx)(n.code,{children:"runtime_request"})," assignment:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"# ...\n\ndatabase_driver = input_yaml.dig('spec', 'database', 'driver')\n\nif database_driver == \"postgresql\" then\n  # The PostgreSQL Request\n  database_request = {\n    'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n    'kind' => 'postgresql',\n    'metadata' => {\n      'name' => app_name + '-db',\n      'namespace' => namespace\n    },\n    'spec' => {\n      'env' => 'dev',\n      'teamId' => app_name,\n      'dbName' => app_name + '-db'\n    }\n  }\n\n  # This is the secret name the PostgreSQL promise will generate\n  secret_name=\"#{app_name}.#{app_name}-#{app_name}-db-postgresql.credentials.postgresql.acid.zalan.do\"\n\n  ## Injecting the secrets into the application env\n  runtime_request['spec']['applicationEnv'].push({\n    'name' => 'PGHOST',\n    'value' => '${app_name}-${app_name}-db-postgresql.default.svc.cluster.local'\n  }, {\n    'name' => 'DBNAME',\n    'value' => '${app_name}-db'\n  }, {\n    'name' => 'PGUSER',\n    'valueFrom' => {\n      'secretKeyRef' => { 'name' => secret_name, 'key' => 'username' }\n    }\n  }, {\n      'name' => 'PGPASSWORD',\n      'valueFrom' => {\n        'secretKeyRef' => { 'name' => secret_name, 'key' => 'password' }\n      }\n    }\n  )\n\n  File.write('/kratix/output/postgresql-request.yaml', database_request.to_yaml)\nend\n"})}),"\n",(0,s.jsxs)(n.admonition,{title:"Where is the connection details coming from?",type:"tip",children:[(0,s.jsxs)(n.p,{children:["The PostgreSQL Promise generates a Secret and a Service as part of its resource workflow. The Runtime Promise provides the ",(0,s.jsx)(n.code,{children:"spec.applicationEnv"})," property, which allows us to inject environment variables directly into the application."]}),(0,s.jsx)(n.p,{children:"By combining these two mechanisms, we can seamlessly construct the connection details for the application."})]}),"\n",(0,s.jsx)(n.h4,{id:"adding-the-redis-request",children:"Adding the Redis Request"}),"\n",(0,s.jsx)(n.p,{children:"Finally, we do the same with the Redis Promise. It's API looks like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: marketplace.kratix.io/v1alpha1\nkind: redis\nmetadata:\n  name: example\n  namespace: default\nspec:\n  size: small\n"})}),"\n",(0,s.jsx)(n.p,{children:"Simple. Similar to the PostgreSQL request, when the user requests a cache, we should add the Redis request to the output directory and inject the connection details into the Runtime request. Right after the PostgreSQL block you just added, include the following:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"\ncache_driver = input_yaml.dig('spec', 'cache', 'driver')\n\nif cache_driver == \"redis\" then\n  redis_request = {\n    'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n    'kind' => 'redis',\n    'metadata' => {\n      'name' => app_name + '-cache',\n      'namespace' => namespace\n    },\n    'spec' => {\n      'size' => 'small'\n    }\n  }\n\n  runtime_request['spec']['applicationEnv'].push({\n    'name' => 'REDIS_URL',\n    'value' => \"redis://rfs-#{app_name}-cache:26379/1\"\n  }, {\n    'name' => 'REDIS_POOL_SIZE',\n    'value' => '5'\n  })\n\n  File.write('/kratix/output/redis-request.yaml', redis_request.to_yaml)\nend\n"})}),"\n",(0,s.jsx)(n.p,{children:"And that's it. Workflow done!"}),"\n",(0,s.jsxs)(i,{children:[(0,s.jsxs)("summary",{children:["Click here for the complete ",(0,s.jsx)(n.code,{children:"pipeline.rb"})," script"]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:"#!/usr/bin/env ruby\n\nrequire 'yaml'\n\n# Read the input YAML file\ninput_yaml = YAML.load_file('/kratix/input/object.yaml')\n\n# Extract values from input\napp_name = input_yaml['metadata']['name']\nnamespace = input_yaml['metadata']['namespace']\napp_image = input_yaml['spec']['image']\n\n# Create the Runtime request\nruntime_request = {\n  'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n  'kind' => 'Runtime',\n  'metadata' => {\n    'name' => app_name,\n    'namespace' => namespace\n  },\n  'spec' => {\n    'image' => app_image,\n    'replicas' => 1,\n    'servicePort' => 80,\n    'applicationEnv' => [\n      { 'name' => 'PORT', 'value' => '80' }\n    ]\n  }\n}\n\ndatabase_driver = input_yaml.dig('spec', 'database', 'driver')\n\nif database_driver == \"postgresql\" then\n  # The PostgreSQL Request\n  database_request = {\n    'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n    'kind' => 'postgresql',\n    'metadata' => {\n      'name' => app_name + '-db',\n      'namespace' => namespace\n    },\n    'spec' => {\n      'env' => 'dev',\n      'teamId' => app_name,\n      'dbName' => app_name + '-db'\n    }\n  }\n\n  # This is the secret name the PostgreSQL promise will generate\n  secret_name=\"#{app_name}.#{app_name}-#{app_name}-db-postgresql.credentials.postgresql.acid.zalan.do\"\n\n  ## Injecting the secrets into the application env\n  runtime_request['spec']['applicationEnv'].push({\n    'name' => 'PGHOST',\n    'value' => '${app_name}-${app_name}-db-postgresql.default.svc.cluster.local'\n  }, {\n    'name' => 'DBNAME',\n    'value' => '${app_name}-db'\n  }, {\n    'name' => 'PGUSER',\n    'valueFrom' => {\n      'secretKeyRef' => { 'name' => secret_name, 'key' => 'username' }\n    }\n  }, {\n      'name' => 'PGPASSWORD',\n      'valueFrom' => {\n        'secretKeyRef' => { 'name' => secret_name, 'key' => 'password' }\n      }\n    }\n  )\n\n  File.write('/kratix/output/postgresql-request.yaml', database_request.to_yaml)\nend\n\ncache_driver = input_yaml.dig('spec', 'cache', 'driver')\n\nif cache_driver == \"redis\" then\n  redis_request = {\n    'apiVersion' => 'marketplace.kratix.io/v1alpha1',\n    'kind' => 'redis',\n    'metadata' => {\n      'name' => app_name + '-cache',\n      'namespace' => namespace\n    },\n    'spec' => {\n      'size' => 'small'\n    }\n  }\n\n  runtime_request['spec']['applicationEnv'].push({\n    'name' => 'REDIS_URL',\n    'value' => \"redis://rfs-#{app_name}-cache:26379/1\"\n  }, {\n    'name' => 'REDIS_POOL_SIZE',\n    'value' => '5'\n  })\n\n  File.write('/kratix/output/redis-request.yaml', redis_request.to_yaml)\nend\n\n# Write to Runtime request to the output file\nFile.write('/kratix/output/runtime-request.yaml', runtime_request.to_yaml)\n"})})]}),"\n",(0,s.jsx)(n.p,{children:"There are only two things left to do in our Compound Promise:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Ensure the outputs of the pipeline are scheduled to the Platform cluster"}),"\n",(0,s.jsx)(n.li,{children:"Set the sub-Promises as requirements for the Compound Promise"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The next sections will explore how to do this."}),"\n",(0,s.jsx)(n.h3,{id:"scheduling-to-the-platform-cluster",children:"Scheduling to the Platform cluster"}),"\n",(0,s.jsx)(n.p,{children:"Let take a moment to revisit the behaviour of installing a normal Promise. When a Promise is applied on the Platform cluster, Kratix ensures the API defined within the Promise becomes available in the Platform as a CRD, which enable users to make request to those Promises. The Promise dependencies, on the other hand, are installed on any Destination that could run the workloads."}),"\n",(0,s.jsx)(n.p,{children:"The Runtime Promise we will use, for example, has a dependency on the Nginx Controller. When that promise is applied, that dependency is installed into any Destination that can receive Runtime instances. When a user requests a new instance, they use the Runtime Promise API to trigger the workflows, that will in turn generate the documents that will be scheduled to the Destination."}),"\n","\n",(0,s.jsxs)("figure",{className:"diagram",children:[(0,s.jsx)("img",{className:"large",src:o,alt:"The Runtime Promise"}),(0,s.jsx)("figcaption",{children:"The Runtime Promise and it's point of interaction"})]}),"\n",(0,s.jsx)(n.p,{children:"Compound Promises behave the exact same way: in response of a user's request, a workflow is executed and a set of documents are generated. Those documents are stored in the State Store to be picked up by a GitOps agent. The difference here is that those documents are themselves requests for other Promises. That means that the Cluster reconciling on the State Store must be able to understand the CRD of the sub-Promises. In most cases, that means scheduling the documents to the Platform cluster itself."}),"\n","\n",(0,s.jsxs)("figure",{className:"diagram",children:[(0,s.jsx)("img",{className:"large",src:l,alt:"The Platform cluster reconciling on the State store"}),(0,s.jsx)("figcaption",{children:"Scheduling documents to the Platform cluster"})]}),"\n",(0,s.jsx)(n.p,{children:"To ensure that the documents generated by the RubyApp Promise are scheduled to the Platform cluster, we need to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Create a Destination representing the platform with some specific labels, like ",(0,s.jsx)(n.code,{children:"environment=platform"})]}),"\n",(0,s.jsx)(n.li,{children:"Configure the GitOps agent in the Platform cluster"}),"\n",(0,s.jsx)(n.li,{children:"Add Destination Selectors in the Compound Promise."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We won't go into detail about (1) and (2) in this blog post. You can find more information about how to ",(0,s.jsx)(n.a,{href:"/workshop/multiple-promises#register-the-platform-as-a-destination",children:"Registering the Platform as a Destination"})," in the Kratix workshop."]}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsx)(n.p,{children:"To quickly get an environment compatible with the promises in this blog post, clone Kratix and run:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"make quick-start\nmake prepare-platform-as-destination\n"})})]}),"\n",(0,s.jsx)(n.p,{children:"At this stage, you should see the following when listing the Destinations in your Platform cluster:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $PLATFORM get destinations --show-labels\nNAME               READY   LABELS\nplatform-cluster   True    environment=platform\nworker-1           True    environment=dev\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For (3), open your Promise file and, under ",(0,s.jsx)(n.code,{children:"spec"}),", add the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  creationTimestamp: null\n  name: rubyapp\nspec:\n  #highlight-start\n  destinationSelectors:\n  - matchLabels:\n      environment: platform\n  #highlight-end\n  api: #...\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["It is possible to dynamically generate the destination selectors by creating a ",(0,s.jsx)(n.code,{children:"destination-selectors.yaml"})," file in the ",(0,s.jsx)(n.code,{children:"/kratix/metadata/"})," directory in the Workflow. You can read more about it in ",(0,s.jsx)(n.a,{href:"/main/reference/destinations/multidestination-management",children:"Managing Multiple Destinations"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["The above declaration tells Kratix to schedule the outputs of this Promise to a Destination with the label ",(0,s.jsx)(n.code,{children:"environment=platform"}),". Since we configured the Platform destination with this label, we already have everything in place for the RubyApp Promise to work."]}),"\n",(0,s.jsx)(n.h3,{id:"defining-the-promise-requirements",children:"Defining the Promise Requirements"}),"\n",(0,s.jsxs)(n.p,{children:["The final piece missing in our Compound Promise is the declaration of the sub-Promises it depends on. For that, you set the ",(0,s.jsx)(n.code,{children:"spec.requiredPromises"})," field in the Compound Promise document with a list of sub-Promise names and versions."]}),"\n",(0,s.jsx)(n.p,{children:"Let's update our RubyApp Promise to include the required sub-Promises:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  creationTimestamp: null\n  name: rubyapp\nspec:\n  #highlight-start\n  requiredPromises:\n  - name: postgresql\n    version: v1.0.0-beta.2\n  - name: redis\n    version: v0.1.0\n  - name: runtime\n    version: v1.0.0\n  #highlight-end\n  destinationSelectors: #..\n  api: #...\n"})}),"\n",(0,s.jsx)(n.p,{children:"We are now ready to install it!"}),"\n",(0,s.jsx)(n.h2,{id:"install",children:"Installing the Promise"}),"\n",(0,s.jsx)(n.p,{children:"If we try to install the Compound Promise now, you should get a warning:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:'$ kubectl --context $PLATFORM apply --filename promise.yaml\nWarning: Required Promise "postgresql" at version "v1.0.0-beta.2" not installed\nWarning: Required Promise "redis" at version "v1.0.0-beta.1" not installed\nWarning: Required Promise "runtime" at version "v0.1.0" not installed\nWarning: Promise will not be available until the above issue(s) is resolved\npromise.platform.kratix.io/rubyapp configured\n'})}),"\n",(0,s.jsx)(n.p,{children:"The Compound Promise itself will remain unavailable until the requirements are satisfied."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $PLATFORM get promises\nNAME      STATUS        KIND      API VERSION               VERSION\nrubyapp   Unavailable   RubyApp   internal.platform.io/v1\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To satisfy the ",(0,s.jsx)(n.code,{children:"requiredPromises"})," declaration, you will to, well, install the required promises in your Platform cluster:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"kubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/promise-postgresql/main/promise-release.yaml\nkubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/redis/promise-release.yaml\nkubectl --context $PLATFORM apply --filename https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/runtime/promise-release.yaml\n"})}),"\n",(0,s.jsx)(n.p,{children:"After a few seconds, you should see all the Promises available in your Platform:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $PLATFORM get promises\nNAME         STATUS      KIND         API VERSION                      VERSION\npostgresql   Available   postgresql   marketplace.kratix.io/v1alpha1   v1.0.0-beta.2\nredis        Available   redis        marketplace.kratix.io/v1alpha1   v0.1.0\nrubyapp      Available   RubyApp      internal.platform.io/v1\nruntime      Available   Runtime      marketplace.kratix.io/v1alpha1   v1.0.0\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["You may have noticed that we are applying a different type of resource: a Promise Release. This blog post will not go into detail on the Promise Releases, but you can find more information on them ",(0,s.jsx)(n.a,{href:"/main/reference/promises/releases",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"You are now ready to send requests to your Compound Promise!"}),"\n",(0,s.jsx)(n.h2,{id:"testing-it-all-together",children:"Testing it all together"}),"\n",(0,s.jsx)(n.p,{children:"Now that you have everything set in the Platform, you can go ahead and deploy the your applications!"}),"\n",(0,s.jsx)(n.p,{children:"For that, create a request for your RubyApp Promise:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"cat <<EOF | kubectl --context $PLATFORM apply -f -\napiVersion: internal.platform.io/v1\nkind: RubyApp\nmetadata:\n  name: myapp\nspec:\n  image: syntasso/example-rails-app:v1.0.0 # you can use this one, or build your own\n  database:\n    driver: postgresql\n  cache:\n    driver: redis\nEOF\n"})}),"\n",(0,s.jsx)(n.p,{children:"Sending this request will immediately trigger the RubyApp Promise Resource workflow. That, in turn, should trigger the sub-promises workflows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"$ kubectl --context $PLATFORM get pods\nNAME                                                        READY   STATUS      RESTARTS   AGE\nkratix-postgresql-myapp-db-instance-configure-abcc3-brgbh   0/1     Completed   0          46s\nkratix-redis-myapp-redis-instance-configure-d2c53-rqf8s     0/1     Completed   0          46s\nkratix-rubyapp-myapp-instance-c87d1-k892w                   0/1     Completed   0          53s\nkratix-runtime-myapp-instance-2ecbc-2lstz                   0/1     Completed   0          45s\n"})}),"\n",(0,s.jsx)(n.p,{children:"In a couple of minutes, in your Worker cluster, you should see the application pod running, alongside the Redis and PostgreSQL databases:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell-session",children:"NAME                                              READY   STATUS        RESTARTS   AGE\nmyapp-7c7cffcc5f-7wrdd                            1/1     Running       0          33s\nmyapp-myapp-db-postgresql-0                       1/1     Running       0          32s\nrfr-myapp-redis-0                                 1/1     Running       0          33s\nrfs-myapp-redis-5cb45649b4-mx5wq                  1/1     Running       0          33s\n# other pods\n"})}),"\n",(0,s.jsx)(n.p,{children:"And you can now access your application:"}),"\n",(0,s.jsxs)(n.admonition,{type:"tip",children:[(0,s.jsxs)(n.p,{children:["If you used the quick-start command to set up your environment, you can access the application at ",(0,s.jsx)(n.a,{href:"http://myapp.default.local.gd:31338/",children:"http://myapp.default.local.gd:31338/"}),". Otherwise, you may need to port-forward to the application pod."]}),(0,s.jsx)(n.p,{children:"You also may need a couple of refreshes to get the green checks, as the database and cache may take a few seconds to be ready."})]}),"\n","\n",(0,s.jsxs)("figure",{className:"diagram",children:[(0,s.jsx)("img",{className:"large",src:d,alt:"Rails application running with PostgreSQL and Redis "}),(0,s.jsx)("figcaption",{children:"The running Rails App"})]}),"\n",(0,s.jsx)(n.p,{children:"\ud83c\udf89 The App is up-and-running! The RubyApp Promise has successfully orchestrated the provisioning of the PostgreSQL and Redis databases, and the deployment of the application. It then wired the application to the databases by injecting the connection details into the environment variables."}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"We've just taken a deep dive into building a Compound Promise from the ground up. From defining a user-centric experience to orchestrating sub-promises, we've walked through each critical step of creating flexible platform abstractions."}),"\n",(0,s.jsx)(n.p,{children:"The magic of Compound Promises lies not just in their technical implementation, but in their ability to abstract away complexity while keeping extensibility at the forefront. The RubyApp Promise we built today is just the beginning\u2014imagine the platforms you could create!"}),"\n",(0,s.jsxs)(n.p,{children:["I hope this post gives you a good base to build your own developer experiences with Compound Promises. As always, feel free to drop by our ",(0,s.jsx)(n.a,{href:"https://kratix.slack.com",children:"Slack"})," or ",(0,s.jsx)(n.a,{href:"https://github.com/syntasso/kratix",children:"GitHub"})," to continue the conversation."]})]})}function g(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);