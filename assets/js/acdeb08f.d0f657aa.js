"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[9238],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(96540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},53418:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"main/platform-concepts/resiliency","title":"Resiliency","description":"How Kratix supports resilient platform operations.","source":"@site/docs/main/05-platform-concepts/01-resiliency.mdx","sourceDirName":"main/05-platform-concepts","slug":"/main/platform-concepts/resiliency","permalink":"/main/platform-concepts/resiliency","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/main/05-platform-concepts/01-resiliency.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Resiliency","description":"How Kratix supports resilient platform operations.","sidebar_label":"Resiliency","sidebar_position":1},"sidebar":"mainSidebar","previous":{"title":"Platform Concepts","permalink":"/category/platform-concepts"},"next":{"title":"Overview","permalink":"/main/platform-concepts/kratix-resources"}}');var t=r(74848),s=r(28453);const a={title:"Resiliency",description:"How Kratix supports resilient platform operations.",sidebar_label:"Resiliency",sidebar_position:1},o=void 0,l={},c=[{value:"Resiliency model overview",id:"resiliency-model-overview",level:2},{value:"How Kratix stores and acts on intent",id:"how-kratix-stores-and-acts-on-intent",level:2},{value:"Where Kratix state lives",id:"where-kratix-state-lives",level:3},{value:"Workflow-related state",id:"workflow-related-state",level:4},{value:"Persisted intent and restart behaviour",id:"persisted-intent-and-restart-behaviour",level:3},{value:"Reconciliation and eventual consistency",id:"reconciliation-and-eventual-consistency",level:3},{value:"How workflows drive convergence",id:"how-workflows-drive-convergence",level:4},{value:"High availability (HA) design",id:"high-availability-ha-design",level:2},{value:"Deployment model",id:"deployment-model",level:3},{value:"Recommended HA posture",id:"recommended-ha-posture",level:3},{value:"Multi-active Kratix control planes",id:"multi-active-kratix-control-planes",level:3},{value:"Failure modes and behaviour",id:"failure-modes-and-behaviour",level:2},{value:"Kubernetes API unavailable",id:"kubernetes-api-unavailable",level:3},{value:"Kratix unavailable (Kubernetes API available)",id:"kratix-unavailable-kubernetes-api-available",level:3},{value:"StateStore unavailable (Git, S3)",id:"statestore-unavailable-git-s3",level:3},{value:"External API unavailable (called by workflows)",id:"external-api-unavailable-called-by-workflows",level:3},{value:"Workflow idempotency",id:"workflow-idempotency",level:3},{value:"How to validate workflow idempotency",id:"how-to-validate-workflow-idempotency",level:4},{value:"Disaster recovery (DR)",id:"disaster-recovery-dr",level:2},{value:"Define targets with RTO and RPO",id:"define-targets-with-rto-and-rpo",level:3},{value:"Backup strategy",id:"backup-strategy",level:3},{value:"Control plane data (etcd)",id:"control-plane-data-etcd",level:3},{value:"What to back up",id:"what-to-back-up",level:3},{value:"Restore approach",id:"restore-approach",level:3},{value:"StateStore recovery and resync",id:"statestore-recovery-and-resync",level:2},{value:"Periodic rewrites",id:"periodic-rewrites",level:3},{value:"Recovering from StateStore loss",id:"recovering-from-statestore-loss",level:3},{value:"Recovery checklist",id:"recovery-checklist",level:2},{value:"Related docs",id:"related-docs",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This page describes Kratix's approach to implementing resiliency."}),"\n",(0,t.jsx)(n.p,{children:"By the end of this page, you should understand:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:['What "high availability" (HA) and disaster recovery (DR) mean for Kratix',"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How intent is represented and persisted in Kubernetes resources"}),"\n",(0,t.jsx)(n.li,{children:"How reconciliation works at a high level, including eventual consistency"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["How to plan and test disaster recovery for Kratix state","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How your system will behave during different component outages"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"resiliency-model-overview",children:"Resiliency model overview"}),"\n",(0,t.jsx)(n.p,{children:"Kratix is a Kubernetes-native platform control plane: intent is declared as Kubernetes\nresources (CRDs and core resources) and persisted in etcd via kube-apiserver."}),"\n",(0,t.jsx)(n.p,{children:"Kratix converges on that intent using asynchronous reconciliation (event-driven\nplus periodic), so behaviour is eventually consistent rather than synchronous."}),"\n",(0,t.jsx)(n.p,{children:"Availability has two distinct dimensions:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Declaring intent"})," depends on kube-apiserver and etcd availability."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Executing intent"})," depends on Kratix controllers and external dependencies\n(StateStores and APIs)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If Kratix or external dependencies are temporarily unavailable, intent remains\npersisted in etcd, and reconciliation resumes when they recover."}),"\n",(0,t.jsx)(n.p,{children:"For user experience, fast acknowledgement of submitted intent is usually more\nimportant than the exact reconciliation completion time."}),"\n",(0,t.jsx)(n.h2,{id:"how-kratix-stores-and-acts-on-intent",children:"How Kratix stores and acts on intent"}),"\n",(0,t.jsx)(n.p,{children:"Kratix follows the Kubernetes controller pattern. You declare intent by\ncreating or updating Kubernetes resources. Kubernetes persists those resources\ninto its backing store, normally etcd. Kratix observes changes and reconciles\nasynchronously towards the desired state that the resource defines."}),"\n",(0,t.jsx)(n.h3,{id:"where-kratix-state-lives",children:"Where Kratix state lives"}),"\n",(0,t.jsx)(n.p,{children:"Kratix represents all intent and progress as Kubernetes resources. It uses a mix of\ncore resources (for example, Jobs) and custom resources (for example,\nPromises, Resource Requests, etc.) to represent the desired state and observed state."}),"\n",(0,t.jsx)(n.p,{children:"All Kubernetes resources follow the same convention:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"spec"})," describes the desired state (what you want Kratix to achieve)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"status"})," describes the observed state (what has happened so far)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These resources are persisted by kube-apiserver into etcd, the backing data\nstore for Kubernetes cluster state. etcd uses the Raft consensus algorithm to\nmaintain a consistent replicated log and elect a leader. This matters because:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"etcd replicates committed data across members, so quorum is required for\ndurable writes."}),"\n",(0,t.jsx)(n.li,{children:"Availability of the Kubernetes API for writes is tied to etcd availability."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You do not need to understand Raft in detail to operate Kratix, but you do need\nto treat the Kubernetes control plane and etcd durability as the primary\navailability boundary for Kratix."}),"\n",(0,t.jsx)(n.h4,{id:"workflow-related-state",children:"Workflow-related state"}),"\n",(0,t.jsxs)(n.p,{children:["A major part of Kratix reconciliation is orchestrating Workflows defined within\nPromises. Workflow execution and its declarative outputs (e.g., Terraform files)\nare represented as Kubernetes resources ",(0,t.jsxs)(n.a,{href:"/main/platform-concepts/kratix-resources#output-objects",children:["called ",(0,t.jsx)(n.code,{children:"Work"}),"s and the scheduling of\nthem as\n",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s"]}),".\nLike other cluster state, ",(0,t.jsx)(n.code,{children:"Work"}),"/",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s are persisted to etcd."]}),"\n",(0,t.jsxs)(n.p,{children:["This matters for HA/DR because ",(0,t.jsx)(n.code,{children:"Work/WorkPlacement"})," is replayable from the control plane: after a\nrestart, Kratix can observe existing ",(0,t.jsx)(n.code,{children:"Work/WorkPlacement"})," resources and continue convergence."]}),"\n",(0,t.jsxs)(n.p,{children:["Destinations represent systems that Kratix can write documents to, which are\nthen reconciled by an external tool (for example, Flux, Argo CD, or Terraform\nEnterprise). They are conceptually similar to nodes in Kubernetes: Destinations\nhave labels, and ",(0,t.jsx)(n.code,{children:"Work"})," uses selectors to match eligible Destinations. Kratix\nthen creates a ",(0,t.jsx)(n.code,{children:"WorkPlacement"})," to record the chosen Destination for that\n",(0,t.jsx)(n.code,{children:"Work"}),", similar to how a scheduler selects a node for a workload and records\nthe decision by creating a Pod."]}),"\n",(0,t.jsxs)(n.p,{children:["It is important to restore ",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s during disaster recovery. A ",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"\nrecords the intent of which destination the ",(0,t.jsx)(n.code,{children:"Work"})," was scheduled to. If a ",(0,t.jsx)(n.code,{children:"Work"}),"\nmatches multiple eligible destinations, Kratix will select a destination at random from\nthose matched by the selector. If the ",(0,t.jsx)(n.code,{children:"WorkPlacement"})," is missing after restore, the\n",(0,t.jsx)(n.code,{children:"Work"})," may be scheduled to a different destination."]}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsxs)(n.mdxAdmonitionTitle,{children:["Back up and restore ",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s"]}),(0,t.jsxs)(n.p,{children:["Ensure your backups include ",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s and validate they are present\nafter restore before re-enabling automation."]}),(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"WorkPlacement"}),"s are missing, the scheduler can make a new selection and\nplace ",(0,t.jsx)(n.code,{children:"Work"})," on a different Destination. That can cause non-deterministic\nplacement and unexpected drift."]})]}),"\n",(0,t.jsx)(n.h3,{id:"persisted-intent-and-restart-behaviour",children:"Persisted intent and restart behaviour"}),"\n",(0,t.jsx)(n.p,{children:"Because intent is stored in etcd (via kube-apiserver), it survives Kratix restarts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Restarting the Kratix pod does not remove or reset the desired state."}),"\n",(0,t.jsx)(n.li,{children:"When Kratix starts, it lists existing Kratix resources and\nresumes reconciliation by reacting to the current cluster state and subsequent changes."}),"\n",(0,t.jsx)(n.li,{children:"Reconciliation continues from what is stored in the cluster state, not from\nin-memory queues."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This is the core of Kratix resiliency: the control plane stores intent, and Kratix\ncan always resume convergence after a restart."}),"\n",(0,t.jsx)(n.h3,{id:"reconciliation-and-eventual-consistency",children:"Reconciliation and eventual consistency"}),"\n",(0,t.jsx)(n.p,{children:"Kratix is an eventually consistent system:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Changes are acted on asynchronously."}),"\n",(0,t.jsx)(n.li,{children:"Convergence time depends on workflow execution time and external dependencies\n(for example, StateStores)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Reconciliation happens in two ways:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Event-driven reconciliation"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Creating, updating, or deleting a Kratix resource triggers reconciliation."}),"\n",(0,t.jsx)(n.li,{children:"Changes to related resources can also trigger reconciliation."}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.a,{href:"/main/reference/resources/reconciliation-labels#manual-reconciliation",children:"manual trigger of reconciliation"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Periodic reconciliation"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Periodic reconciliation is enabled by default."}),"\n",(0,t.jsxs)(n.li,{children:["The interval is configurable at\n",(0,t.jsx)(n.a,{href:"/main/reference/kratix-config/config",children:"Kratix config"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Periodic reconciliation helps recover from transient failures and makes the\nsystem more robust to missed events."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"how-workflows-drive-convergence",children:"How workflows drive convergence"}),"\n",(0,t.jsx)(n.p,{children:"Workflows defined within Promises produce end state via one or both of the following:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Imperative:"})," making API calls to external services (for example, cloud providers)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Declarative:"})," generating documents (for example Terraform files) that Kratix\nthen schedules to different StateStores (for example Git or S3)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Workflows are intended to be idempotent so that retries and restarts are safe."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Declarative output is recorded in-cluster as ",(0,t.jsx)(n.code,{children:"Work/WorkPlacement"})," resources\n(persisted to etcd), which makes it observable and replayable during recovery."]}),"\n",(0,t.jsx)(n.li,{children:"Imperative effects persist in the external systems they target, and recovery may\ndepend on the idempotency and drift handling of those systems and workflows."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"high-availability-ha-design",children:"High availability (HA) design"}),"\n",(0,t.jsx)(n.p,{children:"This section describes how to run Kratix with high availability in a single\nKubernetes cluster."}),"\n",(0,t.jsxs)(n.admonition,{title:'What "high availability" means for Kratix',type:"note",children:[(0,t.jsx)(n.p,{children:"Kratix is not a synchronous service with strict per-request availability\nexpectations. It is a reconciliation system optimized for correctness over\ntime. In practice, evaluating HA for Kratix means:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Can we keep declaring intent during incidents (kube-apiserver available)?"}),"\n",(0,t.jsx)(n.li,{children:"Does the platform reliably converge once Kratix and dependencies recover?"}),"\n"]}),(0,t.jsx)(n.p,{children:"While both are important, in many environments, a request being accepted\nimmediately with clear acknowledgement is a better user outcome than blocking\nsubmission."})]}),"\n",(0,t.jsx)(n.h3,{id:"deployment-model",children:"Deployment model"}),"\n",(0,t.jsx)(n.p,{children:"Kratix runs as a Kubernetes Deployment."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can configure multiple replicas, but only one replica is active at a\ntime."}),"\n",(0,t.jsxs)(n.li,{children:["Kratix uses Kubernetes leader election (implemented via ",(0,t.jsx)(n.code,{children:"Lease"})," objects), so\na single leader performs reconciliation."]}),"\n",(0,t.jsx)(n.li,{children:"If the active replica fails, Kubernetes can restart it, or another replica can\nacquire the leader lease and continue processing."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This gives fast failover without multiple reconcilers acting on the same state."}),"\n",(0,t.jsx)(n.h3,{id:"recommended-ha-posture",children:"Recommended HA posture"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Run multiple replicas"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Multiple replicas reduce time to recovery when the active pod is\nrescheduled."}),"\n",(0,t.jsx)(n.li,{children:"Leader election ensures a single active reconciler."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Spread replicas across failure domains"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use node and zone spreading so a single node or zone outage does not take\nout all replicas."}),"\n",(0,t.jsx)(n.li,{children:"Align placement with your cluster availability requirements."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Treat the Kratix pod as disposable"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Design for restarts and rescheduling."}),"\n",(0,t.jsx)(n.li,{children:"Focus availability investment on the Kubernetes control plane, because it\nstores the intent Kratix needs to function."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Prioritise Kubernetes control plane availability"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"kube-apiserver and etcd availability determine whether intent can be\ndeclared and persisted."}),"\n",(0,t.jsx)(n.li,{children:"Managed Kubernetes offerings often provide well-tested control plane HA\npatterns. Validate what your platform provides and what failure modes it\ncovers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"multi-active-kratix-control-planes",children:"Multi-active Kratix control planes"}),"\n",(0,t.jsx)(n.p,{children:"Our recommendation is to avoid running two independent Kratix control planes\nthat both attempt to reconcile the same desired state."}),"\n",(0,t.jsx)(n.p,{children:"Some teams may still choose this design to meet specific constraints. If so,\nbe explicit about the operational trade-off and test failure behaviour\nthoroughly."}),"\n",(0,t.jsx)(n.p,{children:"Running multi-active reconcilers against the same desired state can introduce\nsplit-brain behaviour and operational instability:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"conflicting decisions against the same resources and destinations"}),"\n",(0,t.jsx)(n.li,{children:"oscillation between states as each reconciler attempts to converge"}),"\n",(0,t.jsx)(n.li,{children:"inconsistent reconciliation ordering across controllers and destinations"}),"\n",(0,t.jsx)(n.li,{children:"more complex incident response because ownership of a change is harder to\nattribute during failures"}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"If you believe active-active is required for your setup, please reach out to\nSyntasso for a more in-depth discussion of the design."})}),"\n",(0,t.jsx)(n.h2,{id:"failure-modes-and-behaviour",children:"Failure modes and behaviour"}),"\n",(0,t.jsx)(n.p,{children:"This section describes what continues to work, what pauses, and what to expect\nwhen the system recovers."}),"\n",(0,t.jsx)(n.h3,{id:"kubernetes-api-unavailable",children:"Kubernetes API unavailable"}),"\n",(0,t.jsx)(n.p,{children:"Impact:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You cannot create, update, or delete Kratix resources through the Kubernetes\nAPI."}),"\n",(0,t.jsx)(n.li,{children:"Kratix cannot read the cluster state, so it cannot reconcile."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"What to expect:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No new intent can be declared until the kube-apiserver is available again."}),"\n",(0,t.jsx)(n.li,{children:"Once it recovers, reconciliation continues fthe rom persisted cluster state."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you place GitOps in front of Kratix Resource Requests, you can still declare\nintent by committing changes even while Kubernetes is unavailable. When the\ncluster recovers, those changes are applied, and Kratix converges on the new\nstate. This is supported by the ",(0,t.jsx)(n.a,{href:"/ske/integrations/backstage/intro",children:"portal integration"}),"\nand is good practice if you are driving Kratix solely via an API."]}),"\n",(0,t.jsx)(n.h3,{id:"kratix-unavailable-kubernetes-api-available",children:"Kratix unavailable (Kubernetes API available)"}),"\n",(0,t.jsx)(n.p,{children:"Impact:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You can continue to create, update, and delete Kratix resources."}),"\n",(0,t.jsx)(n.li,{children:"Changes are persisted to etcd."}),"\n",(0,t.jsx)(n.li,{children:"Kratix will not execute intent until it recovers."}),"\n",(0,t.jsx)(n.li,{children:"External running services are unaffected."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"What pauses while Kratix is unavailable:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Workflows do not run"}),"\n",(0,t.jsx)(n.li,{children:"Scheduling and actuation do not occur"}),"\n",(0,t.jsx)(n.li,{children:"Writing outputs to StateStores does not occur"}),"\n",(0,t.jsx)(n.li,{children:"Status updates and progress reporting become stale"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"What to expect on recovery:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Kratix re-lists resources, resumes watching, and continues reconciliation from\npersisted intent."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"statestore-unavailable-git-s3",children:"StateStore unavailable (Git, S3)"}),"\n",(0,t.jsx)(n.p,{children:"Impact:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Kratix cannot write workflow outputs to the StateStore while the dependency is\nunavailable."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"What to expect:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Workflows still complete successfully and produce outputs that are stored in etcd."}),"\n",(0,t.jsx)(n.li,{children:"Writes to the StateStore are delayed until the StateStore recovers."}),"\n",(0,t.jsx)(n.li,{children:"Once available, Kratix resumes syncing and converges external state."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"external-api-unavailable-called-by-workflows",children:"External API unavailable (called by workflows)"}),"\n",(0,t.jsx)(n.p,{children:"Impact:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Workflows that call the external API may fail, time out, or be delayed."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"What to expect:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Failures are surfaced through workflow status."}),"\n",(0,t.jsx)(n.li,{children:"A failed workflow does not affect documents that have already been scheduled\nto a StateStore."}),"\n",(0,t.jsx)(n.li,{children:"Convergence resumes once the dependency recovers, subject to workflow retry\nbehaviour and periodic reconciliation."}),"\n",(0,t.jsx)(n.li,{children:"Workflows must be idempotent so retries are safe."}),"\n",(0,t.jsxs)(n.li,{children:["Consider implementing the\n",(0,t.jsx)(n.a,{href:"https://martinfowler.com/bliki/CircuitBreaker.html",children:'"Circuit Breaker" pattern'}),"\nwith sensible timeouts and backoff to avoid repeated failing calls during\noutages."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"workflow-idempotency",children:"Workflow idempotency"}),"\n",(0,t.jsx)(n.p,{children:"Workflows must be idempotent. During normal reconciliation and recovery,\nworkflows may be re-run after a restore, after controller restarts, or after\nexternal dependencies recover."}),"\n",(0,t.jsx)(n.p,{children:"When authoring Promises, treat idempotency as a requirement:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Re-running a workflow converges to the same result"}),"\n",(0,t.jsx)(n.li,{children:"External API calls handle retries safely"}),"\n",(0,t.jsx)(n.li,{children:"Outputs written to StateStores are safe to apply more than once"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For more details, see ",(0,t.jsx)(n.a,{href:"/main/reference/resources/workflows#idempotency",children:"Workflow idempotency"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"how-to-validate-workflow-idempotency",children:"How to validate workflow idempotency"}),"\n",(0,t.jsx)(n.p,{children:"Use a non-production environment to exercise the same workflow multiple times\nagainst the same inputs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Re-run the workflow after a successful run and confirm no unintended changes"}),"\n",(0,t.jsx)(n.li,{children:"Simulate a retry after a partial failure and ensure it converges cleanly"}),"\n",(0,t.jsx)(n.li,{children:"verify that external system calls are idempotent (for example, create-or-update)"}),"\n",(0,t.jsx)(n.li,{children:"Compare outputs written to the StateStore and ensure they are stable"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For workflows that talk to external systems, consider adding idempotency keys or\ndeduplication logic on the external side, where available."}),"\n",(0,t.jsx)(n.h2,{id:"disaster-recovery-dr",children:"Disaster recovery (DR)"}),"\n",(0,t.jsx)(n.p,{children:"Disaster recovery for Kratix is primarily disaster recovery for the Kubernetes\ncluster state that contains Kratix resources."}),"\n",(0,t.jsx)(n.p,{children:"This page provides DR guidance, not a complete runbook for every environment.\nApply and adapt it to your platform topology, security controls, and\noperational model."}),"\n",(0,t.jsx)(n.h3,{id:"define-targets-with-rto-and-rpo",children:"Define targets with RTO and RPO"}),"\n",(0,t.jsx)(n.p,{children:"Define resiliency requirements with explicit RTO and RPO targets."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"RTO (recovery time objective)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How long you can tolerate Kratix being unable to execute intent."}),"\n",(0,t.jsx)(n.li,{children:"In practice: how quickly you need workflows and delivery to resume after an\nincident."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"RPO (recovery point objective)"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How much Kratix state you can tolerate losing, measured as time."}),"\n",(0,t.jsx)(n.li,{children:"For Kratix, this is driven by your backup cadence for Kubernetes resources,\nand by whether you also manage intent via GitOps."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For Kratix, prioritise RTO/RPO for kube-apiserver and etcd so users can submit\nrequests and receive acknowledgement quickly. Reconciliation remains eventually\nconsistent; moderate increases in reconciliation time are often acceptable if\nsubmission and acknowledgement remain available."}),"\n",(0,t.jsx)(n.p,{children:"RTO influences your restore approach and readiness. RPO influences backup\nfrequency and scope. Revisit both as your platform architecture and usage\nchange."}),"\n",(0,t.jsx)(n.p,{children:"Do not use a single RTO/RPO target for every part of the system. Set stricter\ntargets for accepting and persisting intent, and separate targets for\nreconciliation speed."}),"\n",(0,t.jsx)(n.h3,{id:"backup-strategy",children:"Backup strategy"}),"\n",(0,t.jsx)(n.p,{children:"Use a Kubernetes backup tool that captures cluster resources, including CRDs and\ncustom resources. Velero is a common choice."}),"\n",(0,t.jsx)(n.p,{children:"The tool examples on this page are guidance, not a prescriptive runbook. Your exact\nbackup and restore design depends on your cluster setup, security controls,\nGitOps model, and operational constraints."}),"\n",(0,t.jsx)(n.p,{children:"If you use GitOps to manage Kratix resources, your Git repository is a useful\ninput source for restoring intent. It does not replace Kubernetes backups\nbecause it does not capture everything required to operate Kratix (for example,\nin-cluster credentials and RBAC configuration)."}),"\n",(0,t.jsx)(n.h3,{id:"control-plane-data-etcd",children:"Control plane data (etcd)"}),"\n",(0,t.jsx)(n.p,{children:"etcd is the primary durability boundary for Kratix, because it stores all\nKubernetes resources and their status. Treat etcd backups as a first-class DR\nconcern."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Managed clusters:"})," cloud and on-prem managed offerings often include\nautomated etcd snapshots and restore procedures. Validate what your provider\ncovers (RPO, retention, and restore path) and test restores."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Self-managed clusters:"})," schedule regular etcd snapshots to off-cluster\nstorage and rehearse restore procedures as part of DR drills."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Velero (and similar tools) back up Kubernetes resources via the API. That is\nessential, and combined with etcd snapshots, it can provide broad coverage for\ncontrol plane recovery. Choose the DR approach that fits your risk tolerance,\nthen test and verify it regularly with full restore rehearsals."}),"\n",(0,t.jsx)(n.h3,{id:"what-to-back-up",children:"What to back up"}),"\n",(0,t.jsx)(n.p,{children:"Ensure your backups include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Kratix CRDs and resource request CRDs"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All Kratix CRDs"}),"\n",(0,t.jsxs)(n.li,{children:["CRDs created by Promises (the CRDs that back resource requests, for example,\n",(0,t.jsx)(n.code,{children:"redis.marketplace.kratix.io"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Core Kratix CRDs:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"bucketstatestores.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"destinations.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"gitstatestores.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"healthrecords.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"promisereleases.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"promiserevisions.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"promises.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"resourcebindings.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"workplacements.platform.kratix.io"}),"\n",(0,t.jsx)(n.li,{children:"works.platform.kratix.io"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Workflow-related resources"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Jobs"}),"\n",(0,t.jsx)(n.li,{children:"ServiceAccounts"}),"\n",(0,t.jsx)(n.li,{children:"Roles, RoleBindings, ClusterRoles, and ClusterRoleBindings"}),"\n",(0,t.jsx)(n.li,{children:"ConfigMaps required by workflows"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Secrets used by Kratix and workflows"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"StateStore credentials"}),"\n",(0,t.jsx)(n.li,{children:"external API credentials"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Other resources workflows depend on"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Any platform cluster resources that workflows reference or query (for\nexample, via ",(0,t.jsx)(n.code,{children:"kubectl get"})," or API calls)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The exact backup scope varies by environment. Keep an explicit inventory of\nwhat Kratix and your workflows depend on, and update it as dependencies change."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"Restoring Kubernetes resources can overwrite existing state. Test restores in a\nnon-production environment and ensure you understand what will be replaced\nbefore restoring into a live cluster. Perform restores using an environment-specific,\ntested runbook."})}),"\n",(0,t.jsx)(n.h3,{id:"restore-approach",children:"Restore approach"}),"\n",(0,t.jsx)(n.p,{children:"Your restore approach depends on the incident type:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Restore into an existing cluster"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use this when the cluster still exists but has lost state or has been\npartially corrupted."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Recreate the cluster and restore"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use this when the cluster is lost (for example, a full cluster outage)."}),"\n",(0,t.jsx)(n.li,{children:"Restore backups into the new cluster, then let Kratix resume reconciliation."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Restore sequencing matters. If reconciliation tools resume before the cluster state\nis fully restored, they may prune or overwrite resources."}),"\n",(0,t.jsxs)(n.admonition,{title:"GitOps prune risk during restore and migration",type:"danger",children:[(0,t.jsx)(n.p,{children:"External GitOps reconcilers handle source outages differently. When a\nreconciler comes back online, and its source repository is empty, incomplete, or\nstale, some tools can interpret the missing manifests as intentional removals\nand automatically prune the corresponding live resources"}),(0,t.jsx)(n.p,{children:"This can happen during DR recovery, when platform and GitOps components fail at\nthe same time, or during repository migrations (for example, moving from GitHub\nto GitLab) where the new repository is briefly empty."})]}),"\n",(0,t.jsx)(n.p,{children:"Use a tested restore order for your platform. An example order might be:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Temporarily pause GitOps reconciliation and other automation that can apply or\nprune resources"}),"\n",(0,t.jsx)(n.li,{children:"Restore control plane state and required resources (including CRDs, secrets,\nRBAC, and Kratix resources)"}),"\n",(0,t.jsx)(n.li,{children:"Run dry-run or preflight checks where your tooling supports them"}),"\n",(0,t.jsx)(n.li,{children:"Verify restored state and controller health before re-enabling reconciliation"}),"\n",(0,t.jsx)(n.li,{children:"Resume automation in stages and monitor for unexpected prune or drift events"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The precise sequence and safeguards vary by environment. Validate your order in\nregular DR exercises and update this when tooling or architecture changes."}),"\n",(0,t.jsx)(n.p,{children:"After a restore, verify that Kratix can:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"List and watch its resources"}),"\n",(0,t.jsx)(n.li,{children:"Acquire leader election and begin reconciliation"}),"\n",(0,t.jsx)(n.li,{children:"Continue convergence without manual state repair"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Treat backup restore as an operational capability, not a one-off task. Rehearse\nend-to-end recovery regularly and update the runbook as your environment\nchanges."}),"\n",(0,t.jsx)(n.h2,{id:"statestore-recovery-and-resync",children:"StateStore recovery and resync"}),"\n",(0,t.jsx)(n.p,{children:"A StateStore is an external destination where Kratix writes workflow outputs,\nsuch as a Git repository or an S3 bucket."}),"\n",(0,t.jsx)(n.h3,{id:"periodic-rewrites",children:"Periodic rewrites"}),"\n",(0,t.jsx)(n.p,{children:"Kratix periodically rewrites outputs to StateStores to ensure external state\nremains up to date."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The sync interval is configurable."}),"\n",(0,t.jsx)(n.li,{children:"The default interval is 10 hours."}),"\n",(0,t.jsx)(n.li,{children:"You can trigger a rewrite manually by labelling the relevant resource."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"recovering-from-statestore-loss",children:"Recovering from StateStore loss"}),"\n",(0,t.jsx)(n.p,{children:"If a Git repository or S3 bucket is lost or replaced:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Recreate the repository or bucket and update the StateStore configuration if\nrequired."}),"\n",(0,t.jsx)(n.li,{children:"Trigger a resync (or wait for the periodic rewrite) so Kratix repopulates the\ndestination from the desired state stored in Kubernetes."}),"\n",(0,t.jsx)(n.li,{children:"Pause GitOps reconcilers until the destination is repopulated and validated\nagainst the expected state."}),"\n",(0,t.jsx)(n.li,{children:"Avoid enabling prune behaviour until the repository contents are complete and\nstable for your environment."}),"\n",(0,t.jsx)(n.li,{children:"Resume reconciliation in stages and monitor for drift, because a large gap\nbetween cluster state and repository state can take time to converge safely."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"recovery-checklist",children:"Recovery checklist"}),"\n",(0,t.jsx)(n.p,{children:"Use this as a post-restore validation checklist. Adjust to match your platform\nand keep it in sync with environment changes."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Kubernetes API writable and etcd healthy"}),"\n",(0,t.jsx)(n.li,{children:"Kratix CRDs and namespaces restored"}),"\n",(0,t.jsx)(n.li,{children:"Secrets and ConfigMaps restored (including StateStore credentials)"}),"\n",(0,t.jsx)(n.li,{children:"RBAC restored (Roles, ClusterRoles, and bindings)"}),"\n",(0,t.jsx)(n.li,{children:"Kratix Deployment running and leader election healthy"}),"\n",(0,t.jsx)(n.li,{children:"Controllers reconciling and status progressing"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Work"})," and ",(0,t.jsx)(n.code,{children:"WorkPlacement"})," resources present and consistent"]}),"\n",(0,t.jsx)(n.li,{children:"StateStore resync completed and confirmed"}),"\n",(0,t.jsx)(n.li,{children:"GitOps source repositories populated with expected manifests before\nreconciliation and prune are re-enabled"}),"\n",(0,t.jsxs)(n.li,{children:["GitOps toolkit healthy (for example, Flux ",(0,t.jsx)(n.code,{children:"Kustomization"}),"s or Argo CD Applications)"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-docs",children:"Related docs"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/main/reference/kratix-config/config",children:"Kratix config"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/main/reference/destinations/intro",children:"Destinations"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/main/reference/statestore/intro",children:"StateStores"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/main/reference/resources/workflows#idempotency",children:"Workflow idempotency"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);