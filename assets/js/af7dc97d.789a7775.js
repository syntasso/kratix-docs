"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[4638],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}},9545:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"ske/guides/healthchecks-nonk8s","title":"Health Checks for non Kubernetes resources","description":"Implementing non Kubernetes Resource Health Checks","source":"@site/docs/ske/05-guides/11-healthchecks-nonk8s.mdx","sourceDirName":"ske/05-guides","slug":"/ske/guides/healthchecks-nonk8s","permalink":"/ske/guides/healthchecks-nonk8s","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/ske/05-guides/11-healthchecks-nonk8s.mdx","tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"title":"Health Checks for non Kubernetes resources","description":"Implementing non Kubernetes Resource Health Checks","sidebar_label":"Health Checks for non Kubernetes Resource"},"sidebar":"skeSidebar","previous":{"title":"Health Checks","permalink":"/ske/guides/healthchecks"},"next":{"title":"Introduction","permalink":"/ske/integrations/intro"}}');var a=t(4848),i=t(8453);const r={title:"Health Checks for non Kubernetes resources",description:"Implementing non Kubernetes Resource Health Checks",sidebar_label:"Health Checks for non Kubernetes Resource"},o=void 0,c={},h=[{value:"Pre-requisites",id:"pre-requisites",level:2},{value:"How to run Health Checks on resources outside of your Destination",id:"how-to-run-health-checks-on-resources-outside-of-your-destination",level:2},{value:"Example Promise",id:"example-promise",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"pre-requisites",children:"Pre-requisites"}),"\n",(0,a.jsx)(n.p,{children:"You will need:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["an installation of SKE. Go to ",(0,a.jsx)(n.a,{href:"../kratix/configuring-ske/intro",children:"Configuring SKE"})," and follow the appropriate guide if you haven't done so already."]}),"\n",(0,a.jsxs)(n.li,{children:["a configured and deployed Health Agent. You can do this by following the guide on ",(0,a.jsx)(n.a,{href:"../kratix/ske-health-agent",children:"Configuring the Kubernetes Health Agent"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["It's also recommended that you first read through the guide on ",(0,a.jsx)(n.a,{href:"healthchecks",children:"how to implement resource Health Checks"})," for a more detailed and step-by-step guide on how health checks work in SKE."]}),"\n",(0,a.jsx)(n.p,{children:"In this guide we will explore a Promise that runs Health Checks on non Kubernetes resources."}),"\n",(0,a.jsx)(n.h2,{id:"how-to-run-health-checks-on-resources-outside-of-your-destination",children:"How to run Health Checks on resources outside of your Destination"}),"\n",(0,a.jsxs)(n.p,{children:["Health Checks are implemented in SKE via ",(0,a.jsx)(n.code,{children:"HealthDefinition"})," objects. As part of a Health Definition, you can provide a set of container images that encapsulate your health check logic, including making API calls to external resources that live outside of your Kubernetes Destination."]}),"\n",(0,a.jsx)(n.h2,{id:"example-promise",children:"Example Promise"}),"\n",(0,a.jsx)(n.p,{children:"Here we have an outline of an AWS DB Promise. This Promise provides an AWS RDS as a service."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: aws-rds\nspec:\n  api:\n    apiVersion: apiextensions.k8s.io/v1\n    kind: CustomResourceDefinition\n    metadata:\n      name: rds.aws.marketplace.kratix.io\n    spec:\n      group: aws.marketplace.kratix.io\n      names:\n        kind: RDS\n        plural: rds\n        singular: rds\n      scope: Namespaced\n      versions:\n        - name: v1alpha1\n          schema:\n            openAPIV3Schema:\n              properties:\n                spec:\n...\n          served: true\n          storage: true\n  #highlight-start\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: rds-configure\n          spec:\n            containers:\n              - image: ghcr.io/syntasso/kratix-marketplace/aws-rds-pipelines:v0.1.0\n                name: configure-rds-instance\n                env:\n                  - name: AWS_ACCESS_KEY_ID\n                    valueFrom:\n                      secretKeyRef:\n                        name: aws-rds\n                        key: accessKeyID\n                  - name: AWS_SECRET_ACCESS_KEY\n                    valueFrom:\n                      secretKeyRef:\n                        name: aws-rds\n                        key: secretAccessKey\n              - image: ghcr.io/syntasso/kratix-marketplace/rds-generate-health-check:v0.1.0\n                name: generate-health-check\n                 #highlight-end\n      delete:\n...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There are one two containers within the Resource Configure pipeline 'rds-configure'. The first container ",(0,a.jsx)(n.code,{children:"aws-rds-pipelines"})," will provision and manage the RDS instance.\nWhile the second container ",(0,a.jsx)(n.code,{children:"rds-health-check"})," can schedule a Health Definition that checks for RDS status."]}),"\n",(0,a.jsx)(n.p,{children:"For reference, the generated Health Definition could look like:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: platform.kratix.io/v1alpha1\nkind: HealthDefinition\nmetadata:\n  name: aws-rds-RESOURCE_NAME-RESOURCE_NS\n  namespace: default # this can be any namespace that exists in the Destination\nspec:\n  resourceRef:\n    name: RESOURCE_NAME\n    namespace: RESOURCE_NS\n  promiseRef:\n    name: aws-rds\n  schedule: @hourly\n  input: |\n    name: RESOURCE_NAME\n  workflow:\n    apiVersion: platform.kratix.io/v1alpha1\n    kind: Pipeline\n    metadata:\n      name: healthcheck\n    spec:\n      containers:\n      - image: ghcr.io/syntasso/kratix-marketplace/rds-health-check:v0.1.0\n        name: check-rds-status\n        ...\nEOF\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This Healthcheck Definition will then be scheduled to a Destination and a Kubernetes CronJob will be created to execute container ",(0,a.jsx)(n.code,{children:"rds-health-check"})," on a hourly schedule."]}),"\n",(0,a.jsxs)(n.p,{children:["Logic in the health check container is completely up to you, as long as the container writes the health check result to ",(0,a.jsx)(n.code,{children:"/kratix/output/health-status.yaml"})," with the format:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"state: # can be of unknown, ready, unhealthy, healthy, or degraded\ndetails: # optional additional information to set in the resource request health status\n  ...\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To check the status of a RDS instance, you might have the container ",(0,a.jsx)(n.code,{children:"rds-health-check"})," running a script that queries the instance status."]}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:'#!/usr/bin/env bash\n\nset -euo pipefail\n\n# read data from the input object\nname="$(yq eval \'.metadata.name\' /kratix/input/object.yaml)"\nnamespace="$(yq eval \'.metadata.namespace\' /kratix/input/object.yaml)"\nengine="$(yq eval \'.spec.engine\' /kratix/input/object.yaml)"\n\nregion="eu-west-1"\ndb_identifier="${name}-${namespace}-${engine}"\n\naws rds describe-db-instances --db-instance-identifier ${db_identifier} --region ${region} > instance-output.json\n\ninstance_status=$(jq -r \'.DBInstances[0].DBInstanceStatus\' instance-output.json)\n\ncat <<EOF > /kratix/metadata/status.yaml\ninstanceStatus: ${instance_status}\ninstanceIdentifier: ${db_identifier}\nEOF\n\nif [[ "$instanceStatus" == "available" ]]; then\n    state="healthy"\nelif [[ "$instanceStatus" == "upgrading" || "$instanceStatus" == "starting" ]]; then\n    state="degraded"\nelse\n    state="unknown"\nfi\n\ncat <<EOF > /kratix/output/health-status.yaml\nstate: ${state}\ndetails:\n  instanceStatus: ${instance_status}\nEOF\n\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The above scripts will write the health check result to ",(0,a.jsx)(n.code,{children:"/kratix/output/health-status.yaml"}),".\nThe SKE health agent will then produce a Health Record and write to the registered state store.\nSKE will reconcile the Health Record and update the Resource Request health status."]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);