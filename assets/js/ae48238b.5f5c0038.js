"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[5358],{9640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"workshop/part-ii/status","title":"Section D: Surfacing information via Status","description":"Learn how to surface information to users via the status of a Resource","source":"@site/docs/workshop/part-ii/04-status.mdx","sourceDirName":"workshop/part-ii","slug":"/workshop/part-ii/status","permalink":"/workshop/part-ii/status","draft":false,"unlisted":false,"editUrl":"https://github.com/syntasso/kratix-docs/tree/main/docs/workshop/part-ii/04-status.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"status","title":"Section D: Surfacing information via Status","description":"Learn how to surface information to users via the status of a Resource"},"sidebar":"workshopSidebar","previous":{"title":"Section C: Accessing Secrets and storing state","permalink":"/workshop/part-ii/secrets-and-state"},"next":{"title":"Section E: Making a Compound Promise","permalink":"/workshop/part-ii/compound-promise"}}');var a=n(4848),i=n(8453);n(8069);const o={id:"status",title:"Section D: Surfacing information via Status",description:"Learn how to surface information to users via the status of a Resource"},r=void 0,l={},c=[{value:"Conveying information back to the application developers",id:"metadata",level:2},{value:"Status",id:"status",level:2},{value:"Bonus Challenge",id:"bonus-challenge",level:2},{value:"\ud83c\udf89 \xa0 Congratulations!",id:"--congratulations",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["This is Part 4 of ",(0,a.jsx)(t.a,{href:"intro",children:"a series"})," illustrating how to write Kratix Promises."]}),"\n",(0,a.jsxs)(t.p,{children:["\ud83d\udc48\ud83c\udffe Previous: ",(0,a.jsx)(t.a,{href:"./secrets-and-state",children:"Accessing secrets and storing state"})," ",(0,a.jsx)("br",{}),"\n\ud83d\udc49\ud83c\udffe Next: ",(0,a.jsx)(t.a,{href:"./compound-promise",children:"Writing Compound Promises"})]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.p,{children:"In the previous tutorial, you learned how to access secrets and states from a Pipeline. In this section, you will learn how to surface information to users via the status of a Resource."}),"\n",(0,a.jsx)(t.p,{children:"You will:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"#metadata",children:"Learn about the Metadata directory in Kratix Workflows"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"#status",children:"Learn how to expose information via the Resource Status"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"metadata",children:"Conveying information back to the application developers"}),"\n",(0,a.jsx)(t.p,{children:"What we've focused on so far is how to define a Kratix Promise in a compelling way so that platform users choose to use the platform. A Kratix-powered platform enables users to ask for the services they need, on-demand, without having to know unnecessary business and service lifecycle requirements."}),"\n",(0,a.jsx)(t.p,{children:"What platform users need, though, is the end-to-end experience of making a simple request, understanding what's happening with the request, then ultimately making use of the service created by the request. So how do you communicate information about a request back to platform users, and how do users use the services that the platform creates?"}),"\n",(0,a.jsx)(t.p,{children:"There are actually a number of ways you can communicate the status of a service to the platform, and the choice comes down to the Promise and Promise Workflow author."}),"\n",(0,a.jsx)(t.p,{children:"One approach is to generate notifications for internal systems like Slack or Teams from the Promise Workflow's Pipeline container."}),"\n",(0,a.jsxs)(t.p,{children:["Another approach, which is what we'll choose today, is to follow convention and leverage the ",(0,a.jsx)(t.code,{children:"status"})," field on Kubernetes resources. The Kratix Workflow's Pipeline has the ability to write information back to the status of the Resource."]}),"\n",(0,a.jsx)(t.p,{children:"In the context of your Promise, an example of what you might want to convey back is the configuration of the Resource (e.g. default configuration), and how to access the running Resources (e.g. a URL or connection string)."}),"\n",(0,a.jsx)(t.h2,{id:"status",children:"Status"}),"\n",(0,a.jsxs)(t.p,{children:["As we saw in ",(0,a.jsx)(t.a,{href:"./promise-workflows",children:"Promise Workflows"}),", within the Pipeline container file system, Kratix mounts a ",(0,a.jsx)(t.a,{href:"/main/reference/workflows#metadata",children:(0,a.jsx)(t.code,{children:"/kratix/metadata"})})," directory to manage important configuration that is independent of the Resources definitions for your State Store."]}),"\n",(0,a.jsxs)(t.p,{children:["In this section, you will focus on one of the files in the ",(0,a.jsx)(t.code,{children:"metadata"})," directory: ",(0,a.jsx)(t.code,{children:"status.yaml"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"status.yaml"})," file can contain arbitrary key-value pairs. Anything you write in this file will be persistent in the resource, and visible when the user inspects it."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"message"})," key is a special key that is displayed as part of the ",(0,a.jsx)(t.code,{children:"kubectl get resource"})," command."]}),"\n",(0,a.jsxs)(t.p,{children:["With that in-mind, you can update your existing ",(0,a.jsx)(t.code,{children:"resource-configure"})," script to surface some information about the Resource in the ",(0,a.jsx)(t.code,{children:"status.yaml"})," file. One of the things you may want to surface is, for example, the URL of the running application."]}),"\n",(0,a.jsxs)(t.p,{children:["Add the following lines to the end of your ",(0,a.jsx)(t.code,{children:"resource-configure"})," script:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",metastring:'title="app-promise/workflows/resource/configure/mypipeline/kratix-workshop-app-pipeline-image/scripts/resource-configure',children:'\n# Set the resource status\ncat <<EOF > /kratix/metadata/status.yaml\nmessage: "${name}.local.gd:31338"\nEOF\n'})}),"\n",(0,a.jsx)(t.p,{children:"Next, run the tests:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"./scripts/test-pipeline resource-configure\n"})}),"\n",(0,a.jsx)(t.p,{children:"You should see the following in your local directory:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"\ud83d\udcc1 app-promise\n...\n\u2514\u2500\u2500 test\n\xa0\xa0  \u251c\u2500\u2500 input\n\xa0\xa0  \u2502\xa0\xa0 \u2514\u2500\u2500 object.yaml\n\xa0\xa0  \u251c\u2500\u2500 metadata\n\xa0\xa0  \u2502\xa0\xa0 \u2514\u2500\u2500 status.yaml\n \xa0\xa0 \u2514\u2500\u2500 output\n \xa0\xa0     \u251c\u2500\u2500 deployment.yaml\n \xa0\xa0     \u251c\u2500\u2500 ingress.yaml\n \xa0\xa0     \u2514\u2500\u2500 service.yaml\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If you inspect the ",(0,a.jsx)(t.code,{children:"test/metadata/status.yaml"})," file, you should see something like the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'message: "my-app.local.gd:31338"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Excellent. With that file in place, Kratix will automatically persist that\ninformation to the status of the Resource."}),"\n",(0,a.jsxs)(t.p,{children:["The status that persist to your resource will also be viewable the next time\nthe pipeline runs by inspecting the ",(0,a.jsx)(t.code,{children:"/kratix/input/object.yaml"}),". For example after\nthe very first pipeline has run, all future pipelines would have an input object\nlike the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",metastring:'title="test/input/object.yaml"',children:'apiVersion: workshop.kratix.io/v1\nkind: App\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  image: example/image:v1.0.0\n  service:\n    port: 9000\nstatus:\n  message: "my-app.local.gd:31338"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Great! Now you have a way to persist information about your Resource."}),"\n",(0,a.jsx)(t.p,{children:"This time, you haven't changed the Promise at all, but rather updated the underlying pipeline image. The existing resources will automatically get the new status information on the next reconciliation."}),"\n",(0,a.jsxs)(t.p,{children:["Just like last time, you can force a reconciliation by adding the ",(0,a.jsx)(t.code,{children:"kratix.io/manual-reconciliation = true"})," label:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl --context $PLATFORM label apps.workshop.kratix.io todo kratix.io/manual-reconciliation=true\n"})}),"\n",(0,a.jsx)(t.p,{children:"Once the pipeline completes, you should see the new status information on the Resource:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl --context $PLATFORM describe apps.workshop.kratix.io todo\n"})}),"\n",(0,a.jsx)(t.p,{children:"The above command outputs something similar to the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"Name:         todo\nNamespace:    default\nLabels:       <none>\nAnnotations:  <none>\nAPI Version:  workshop.kratix.io/v1\nKind:         App\nMetadata:\n  Creation Timestamp:  2025-09-09T16:07:10Z\n  Finalizers:\n    kratix.io/work-cleanup\n    kratix.io/workflows-cleanup\n    kratix.io/delete-workflows\n  Generation:        1\n  Resource Version:  814088\n  UID:               19266d15-6362-4a54-85fb-b4965af65c24\nSpec:\n  Image:  syntasso/sample-todo:v0.1.0\n  Service:\n    Port:  8080\nStatus:\n  Conditions:\n    Last Transition Time:                   2025-09-09T16:17:20Z\n    Message:                                Pipelines completed\n    Reason:                                 PipelinesExecutedSuccessfully\n    Status:                                 True\n    Type:                                   ConfigureWorkflowCompleted\n    Last Transition Time:                   2025-09-09T16:17:22Z\n    Message:                                Reconciled\n    Reason:                                 Reconciled\n    Status:                                 True\n    Type:                                   Reconciled\n    Last Transition Time:                   2025-09-09T16:07:18Z\n    Message:                                All works associated with this resource are ready\n    Reason:                                 WorksSucceeded\n    Status:                                 True\n    Type:                                   WorksSucceeded\n  #highlight-start\n  Message:                 todo.local.gd:31338\n  #highlight-end\nEvents:                    <none>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note how the ",(0,a.jsx)(t.code,{children:"status"})," field is now populated with the information you added to the ",(0,a.jsx)(t.code,{children:"status.yaml"})," file."]}),"\n",(0,a.jsx)(t.admonition,{type:"info",children:(0,a.jsxs)(t.p,{children:["You may also notice that there's a condition called ",(0,a.jsx)(t.code,{children:"ConfigureWorkflowCompleted"}),". This is\na special condition that is automatically added to the status of the Resource, and set to\n",(0,a.jsx)(t.code,{children:"True"})," when all Pipelines in the Configure workflow have completed successfully."]})}),"\n",(0,a.jsxs)(t.p,{children:["Furthermore, the value for the ",(0,a.jsx)(t.code,{children:"message"})," key should also be displayed as part of the ",(0,a.jsx)(t.code,{children:"get"})," command:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl --context $PLATFORM get apps.workshop.kratix.io\n"})}),"\n",(0,a.jsx)(t.p,{children:"The above command should output the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell-session",children:"NAME   MESSAGE               STATUS\ntodo   todo.local.gd:31338   Reconciled\n"})}),"\n",(0,a.jsx)(t.h2,{id:"bonus-challenge",children:"Bonus Challenge"}),"\n",(0,a.jsx)(t.p,{children:"We just learned how to persist information about your Resource via using Status.\nAs a bonus challenge, let's take a look at how to ensure that the information in Status is not overwritten if it already exists."}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["Kubernetes automatically adds a ",(0,a.jsx)(t.code,{children:"metadata.creationTimestamp"})," field to all resources. The date you will add to the status is only to illustrate how to add dynamic information to the status."]})}),"\n",(0,a.jsxs)(t.p,{children:["Update your ",(0,a.jsx)(t.code,{children:"resource-configure"})," script so it sets a new field ",(0,a.jsx)(t.code,{children:"createdAt"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",metastring:'title="app-promise/workflows/resource/configure/mypipeline/kratix-workshop-app-pipeline-image/scripts/resource-configure',children:'createdAt="$(date)"\n\n# Set the resource status\ncat <<EOF > /kratix/metadata/status.yaml\ncreatedAt: ${createdAt}\nmessage: "${name}.local.gd:31338"\nEOF\n'})}),"\n",(0,a.jsx)(t.p,{children:"Next, run the tests:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"./scripts/test-pipeline resource-configure\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If you inspect the ",(0,a.jsx)(t.code,{children:"test/metadata/status.yaml"})," file, you should see that there is a new field ",(0,a.jsx)(t.code,{children:"createdAt"})," added:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'createdAt: "Wed Jan 1 15:00:00 UTC 2023"\nmessage: "my-app.local.gd:31338"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["If you run the pipeline again, you will see that the ",(0,a.jsx)(t.code,{children:"createdAt"})," field is updated to the current date. This is because our pipeline is not idempotent. You can fix this by checking the status on the resource, and only updating the status if it is not already set."]}),"\n",(0,a.jsxs)(t.p,{children:["Update your ",(0,a.jsx)(t.code,{children:"workflow/resource-configure"})," script to the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",metastring:'title="app-promise/workflows/resource/configure/mypipeline/kratix-workshop-app-pipeline-image/scripts/resource-configure"',children:'#highlight-start\ncreatedAt=$(yq \'.status.createdAt // ""\' /kratix/input/object.yaml)\nif [ -z "$createdAt" ]; then\n  createdAt="$(date)"\nfi\n#highlight-end\n\n# Set the resource status\ncat <<EOF > /kratix/metadata/status.yaml\ncreatedAt: "${createdAt}"\nmessage: "${name}.local.gd:31338"\nEOF\n'})}),"\n",(0,a.jsx)(t.p,{children:"Now test your changes:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"./scripts/test-pipeline resource-configure\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Inspect the ",(0,a.jsx)(t.code,{children:"test/metadata/status.yaml"})," file. Since your input does not contain the ",(0,a.jsx)(t.code,{children:"status"})," field, you should see today's date in the ",(0,a.jsx)(t.code,{children:"createdAt"})," field. Now, to test that the status is not updated if it already exists, change your test input to look like the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",metastring:'title="test/input/object.yaml"',children:'apiVersion: workshop.kratix.io/v1\nkind: App\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  image: example/image:v1.0.0\n  service:\n    port: 9000\nstatus:\n  createdAt: "Thu Jan 28 15:00:00 UTC 2021"\n  message: "my-app.local.gd:31338"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Re-run the tests:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"./scripts/test-pipeline resource-configure\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If you inspect the ",(0,a.jsx)(t.code,{children:"test/metadata/status.yaml"})," file now, you should see the following:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'createdAt: "Thu Jan 28 15:00:00 UTC 2021"\nmessage: "my-app.local.gd:31338"\n'})}),"\n",(0,a.jsx)(t.p,{children:"Awesome! You now have a way to ensure that the information is not overwritten if it already exists."}),"\n",(0,a.jsxs)(t.p,{children:["Let's force a reconciliation by adding the ",(0,a.jsx)(t.code,{children:"kratix.io/manual-reconciliation = true"})," label:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl --context $PLATFORM label apps.workshop.kratix.io todo kratix.io/manual-reconciliation=true\n"})}),"\n",(0,a.jsx)(t.p,{children:"Once the pipeline completes, you should see the new status information on the Resource:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl --context $PLATFORM describe apps.workshop.kratix.io todo\n"})}),"\n",(0,a.jsx)(t.p,{children:"The above command outputs something similar to the following:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"Name:         todo\nNamespace:    default\nAPI Version:  workshop.kratix.io/v1\nKind:         App\nMetadata:\n  Creation Timestamp:  2024-01-31T15:27:43Z\n...\nSpec:\n  Image:  syntasso/sample-todo:v0.1.0\n  Service:\n    Port:  8080\nStatus:\n...\n  #highlight-start\n  Created At:              Wed Jan 1 15:01:01 UTC 2023\n  #highlight-end\n  Message:                 todo.local.gd:31338\nEvents:                    <none>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note how the ",(0,a.jsx)(t.code,{children:"status"})," field is now populated with the information you added to the ",(0,a.jsx)(t.code,{children:"status.yaml"})," file."]}),"\n",(0,a.jsxs)(t.p,{children:["Try retriggering the reconciliation by adding the label again. You should notice that the ",(0,a.jsx)(t.code,{children:"CreatedAt"})," field is not updated, just like you observed in the test."]}),"\n",(0,a.jsx)(t.h2,{id:"--congratulations",children:"\ud83c\udf89 \xa0 Congratulations!"}),"\n",(0,a.jsx)(t.p,{children:"You successfully surfaced information back to the user by writing to the resource status! You Promise is getting more and more useful."}),"\n",(0,a.jsx)(t.p,{children:"To recap what you achieved:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"\u2705\xa0\xa0Learned how to use metadata to set a custom Resource status"}),"\n",(0,a.jsx)(t.li,{children:"\u2705\xa0\xa0Learned how to make writing to status idempotent"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["\ud83d\udc49\ud83c\udffe\xa0\xa0 Next, let's ",(0,a.jsx)(t.a,{href:"./compound-promise",children:"add support for stateful applications"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);