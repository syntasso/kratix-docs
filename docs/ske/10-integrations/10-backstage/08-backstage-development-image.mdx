---
title: Backstage Development Image
description: Setting up a development Backstage image
sidebar_label: Backstage Development Image
---

:::warning
**NOT FOR PRODUCTION**

This is a development image that is useful for getting started quickly in a development environment. It is not suitable for production use and should be used only for development and testing purposes.
:::

# Backstage Development Image

## Overview

This guide walks you through deploying a development Backstage instance with Syntasso Kratix Enterprise (SKE) plugins pre-installed.

It is:
- ‚úÖ Ideal for local testing and development
- üö´ **Not** suitable for production environments or long term use
- ‚ö†Ô∏è Pre-packaged with fixed assumptions around Kubernetes and S3-compatible storage (not flexible or configurable)

For more advanced or production-ready customization, see the [Configuring Backstage](/ske/integrations/backstage/configuring-backstage) documentation.

---

## Prerequisites

Before you begin, ensure you have:

- A running **Kubernetes cluster**
- Access to an **S3-compatible bucket** (e.g., MinIO or S3)

---

## Configuration

### What You Need to Configure

Below is an example `ConfigMap` for Backstage that includes the necessary
configurations to run with Syntasso Kratix. This needs to be modified to suit
your environment:

- To modify to use your own Bucket update the `endpoint` and `bucketName` in
`integrations.awsS3` and `catalog.providers.awsS3`

- If you plan to expose Backstage by ingress or NodePort, make sure `baseUrl` and `cors.origin` match your setup. If you plan to use `kubectl port-forward` to access Backtage, the default values can remain unchanged.


```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: backstage
  namespace: kratix-platform-system
data:
  config: |
    app:
      title: Backstage Dev Build By Syntasso
      # if your using a nodeport, modify the baseUrl to match the nodeport. Otherwise ignore
      baseUrl: http://localhost:31340
    organization:
      name: app-config
    backend:
      baseUrl: http://localhost:31340
      listen:
        port: 7007
        host: 0.0.0.0
      csp:
        upgrade-insecure-requests: false
        connect-src: ["'self'", "http:", "https:"]
      cors:
        origin: http://localhost:31340
        methods: [GET, HEAD, PATCH, POST, PUT, DELETE]
        credentials: true
      database:
        client: better-sqlite3
        connection: ":memory:"
      cache:
        store: memory
      auth:
        dangerouslyDisableDefaultAuthPolicy: true
    integrations:
      awsS3:
          # We will show how to configure the source of these environment variables later
        - accessKeyId: ${AWS_ACCESS_KEY_ID}
          secretAccessKey: ${AWS_SECRET_ACCESS_KEY}
          # Modify as required
          endpoint: 'http://minio.kratix-platform-system.svc.cluster.local'
          s3ForcePathStyle: true
    techdocs:
      builder: "local"
      generator:
        runIn: "docker"
      publisher:
        type: "local"
    catalog:
      import:
        entityFilename: catalog-info.yaml
        pullRequestBranchName: backstage-integration
      rules:
        - allow:
            [Domain, Component, System, API, Resource, Location, Group, Template]
      locations:
        - type: file
          target: ../../examples/template/template-ske.yaml
          rules:
            - allow: [Template]
        - type: file
          target: ../../examples/entities.yaml
          rules:
            - allow:
                [
                  Domain,
                  Component,
                  System,
                  API,
                  Resource,
                  Location,
                  Group,
                  Template,
                ]
        - type: file
          target: ../../examples/org.yaml
          rules:
            - allow: [User, Group]
      providers:
        awsS3:
          kratix-minio:
            # Modify as required
            bucketName: kratix
            prefix: backstage/
            region: us-east-1
            schedule:
              frequency: { seconds: 10 }
              timeout: { seconds: 20 }
    kubernetes:
      serviceLocatorMethod:
        type: multiTenant
      clusterLocatorMethods:
        - type: config
          clusters:
            - url: "https://kubernetes.default.svc.cluster.local"
              name: platform
              authProvider: serviceAccount
              serviceAccountToken: ${SA_TOKEN}
              skipTLSVerify: true
    ske:
      kubernetes:
        platformName: platform
```


Once you've finished modifying, create the `ConfigMap` in your Kubernetes cluster:

```bash
kubectl apply -f configmap.yaml
```

---

## Installation

Once your `ConfigMap` is ready, all thats left is to deploy Backstage with the
provided manifest below. The manifest will need to be updated to:

- Reference the Bucket secret

- Any ingress modifications you may want to make, such as using as NodePort.

- ClusterRole modifications if you want to limit what Backstage can access. It
needs access to all Promises and all Promise APIs. By default it has
cluster-wide access to all resources.

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: backstage
  name: backstage
  namespace: kratix-platform-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: backstage
  template:
    metadata:
      labels:
        app: backstage
    spec:
      serviceAccountName: backstage
      imagePullSecrets:
      - name: syntasso-registry
      containers:
      - env:
        - name: AWS_ACCESS_KEY_ID
          valueFrom:
            secretKeyRef:
              # update this to your MinIO or S3 bucket credentials
              name: minio-credentials
              key: accessKeyID
        - name: AWS_SECRET_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              # update this to your MinIO or S3 bucket credentials
              name: minio-credentials
              key: secretAccessKey
        - name: SA_TOKEN
          valueFrom:
            secretKeyRef:
              # leave as is, this secret gets created by the manifest
              name: backstage-token
              key: token
        image: registry.syntasso.io/syntasso/backstage-dev-build:v0.12.0-rc49
        imagePullPolicy: IfNotPresent
        name: backstage
        ports:
        - containerPort: 7007
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /config
          name: config
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
      volumes:
      - configMap:
          defaultMode: 420
          items:
          - key: config
            path: app-config.yaml
          name: backstage
        name: config
---
apiVersion: v1
kind: Service
metadata:
  name: backstage
  namespace: kratix-platform-system
spec:
  ports:
    - port: 7007
      protocol: TCP
  selector:
    app: backstage
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backstage
rules:
# Modify these rules to limit what Backstage can access
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: backstage
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: backstage
subjects:
- kind: ServiceAccount
  name: backstage
  namespace: kratix-platform-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backstage
  namespace: kratix-platform-system
---
apiVersion: v1
kind: Secret
metadata:
  name: backstage-token
  namespace: kratix-platform-system
  annotations:
    kubernetes.io/service-account.name: backstage
type: kubernetes.io/service-account-token
```

Once modified and saved, apply the manifest to your cluster:

```bash
kubectl apply -f backstage.yaml
```

## Accessing Backstage

- If using **NodePort** or **Ingress**, visit your corresponding address, e.g: `http://localhost:31340`

- If using **port-forwarding**, run the following command in your terminal:
  ```sh
  kubectl port-forward service/backstage -n kratix-platform-system 7007:7007
  ```
Then navigate to:  `http://localhost:7007`

---

## Next Steps

Now that Backstage is running:

- Follow the [Backstage Destination](https://docs.kratix.io/ske/integrations/backstage/configuring-backstage#configuring-kratix) documentation to setup Kratix to communicate with it.
- Start [integrating it with your Promises](/ske/integrations/backstage/generating-backstage-components).
